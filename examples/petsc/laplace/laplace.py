from devito import *
from devito.types import PETScSolve
import pandas as pd
from devito import configuration
import numpy as np
configuration['opt'] = 'noop'


# Corresponding c code generated by 'op' is found in petsc_solve.c
# This is just temporary - just illustrating the current
# functionality of PETScSolve alongside the lower_petsc pass.


nx = 13
ny = 13
Lx = np.float64(1.)
Ly = np.float64(1.)

# from IPython import embed; embed()
dx = Lx / np.float64(nx - 1)
dy = Ly / np.float64(ny - 1)



class SubTop(SubDomain):
    name = 'subtop'
    def define(self, dimensions):
        x, y = dimensions
        return {x: x, y: ('right', 1)}
sub1 = SubTop()

class SubBottom(SubDomain):
    name = 'subbottom'
    def define(self, dimensions):
        x, y = dimensions
        return {x: x, y: ('left', 1)}
sub2 = SubBottom()

class SubLeft(SubDomain):
    name = 'subleft'
    def define(self, dimensions):
        x, y = dimensions
        return {x: ('left', 1), y: y}
sub3 = SubLeft()

class SubRight(SubDomain):
    name = 'subright'
    def define(self, dimensions):
        x, y = dimensions
        return {x: ('right', 1), y: y}
sub4 = SubRight()

grid = Grid(shape=(nx, ny), extent=(Lx, Ly), subdomains=(sub1,sub2,sub3,sub4,), dtype=np.float64)

pn = Function(name='pn', grid=grid, space_order=2, dtype=np.float64)

rhs = Function(name='rhs', grid=grid, space_order=2, dtype=np.float64)

eqn = Eq(pn.laplace, rhs, subdomain=grid.interior)


# # initialise fields
tmp = np.linspace(0, Lx, nx).astype(np.float64)*np.float64(np.pi)/Lx
top_val = np.float64(np.sin(tmp))


pn.data[:] = np.float64(0.)
pn.data[:, -1] = top_val
rhs.data[:] = np.float64(0.)
rhs.data[:, -1] = top_val


# # Create boundary condition expressions using subdomains
x, y = grid.dimensions

top = Function(name='top', shape=(nx,), dimensions=(x,), dtype=np.float64)
bottom = Function(name='bottom', shape=(nx,), dimensions=(x,), dtype=np.float64)
left = Function(name='left', shape=(ny,), dimensions=(y,), dtype=np.float64)
right = Function(name='right', shape=(ny,), dimensions=(y,), dtype=np.float64)

top.data[:] = top_val
bottom.data[:] = np.float64(0.)
left.data[:] = np.float64(0.)
right.data[:] = np.float64(0.)

# from IPython import embed; embed()

bcs = [Eq(pn, top, subdomain=sub1)]
bcs += [Eq(pn, bottom, subdomain=sub2)]
bcs += [Eq(pn, left, subdomain=sub3)]
bcs += [Eq(pn, right, subdomain=sub4)]

# ksp type, pc type and relative tolerance.
petsc = PETScSolve(eqn, pn, bcs=bcs, solver_parameters={'ksp_type': 'gmres',
                                                                'pc_type': 'jacobi',
                                                                'ksp_rtol': 1e-7,
                                                                'ksp_max_it': 10000})


# build the op
op = Operator(petsc)

# # from IPython import embed; embed()
op.apply()
# # print(pn.data[:])
# print(op.ccode)
print(op.arguments())

# import pandas as pd

pd.DataFrame(pn.data[:]).to_csv("results/1.csv", header=None, index=None)