from devito.passes.iet.engine import iet_pass
from devito.ir.iet import (List, Callable, Call, Transformer,
                           Callback, Definition, Uxreplace, FindSymbols,
                           Iteration, MapNodes, ActionExpr)
from devito.types.petsc import (Mat, Vec, DM, PetscErrorCode, PETScStruct,
                                PETScArray, PetscMPIInt)
from devito.symbolics import FieldFromPointer, Byref
import cgen as c


__all__ = ['lower_petsc']


@iet_pass
def lower_petsc(iet, **kwargs):
    # NOTE: Currently only considering the case when opt='noop'. This
    # does not deal with the Temp Expressions generated when opt is not set
    # to 'noop' etc.

    # Find the largest Iteration loop containing the Action
    iter_expr_mapper = MapNodes(Iteration, ActionExpr).visit(iet)
    with_action = next(iter(iter_expr_mapper), [])

    # Find the original target (i.e the field we are solving for)
    # TODO: Extend to multiple targets but for now assume
    # we are only solving 1 equation via PETSc.
    expr_target = next(iter(iter_expr_mapper.values()), None)
    if expr_target:
        target = [i for i in expr_target[0].functions if not isinstance(i, PETScArray)][0]
       # Build PETSc objects required for the solve.
        petsc_objs = build_petsc_objects(target)
        struct = build_struct(with_action)
        matvec_body = build_matvec_body(with_action, petsc_objs, struct, expr_target)
        matvec_callback, solve_body = build_solve(matvec_body, petsc_objs, struct)
        mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed} 
        matvec_callback = Uxreplace(mapper).visit(matvec_callback)
        action_mapper = {with_action: solve_body}
        iet = Transformer(action_mapper).visit(iet)

        return iet, {'efuncs': [matvec_callback]}

    # # Build PETSc objects required for the solve.
    # petsc_objs = build_petsc_objects(target)

    # Build the struct that is needed within the matvec callback
    # struct = build_struct(with_action)

    # Build the body of the matvec callback
    # matvec_body = build_matvec_body(with_action, petsc_objs, struct, expr_target)

    # matvec_callback, solve_body = build_solve(matvec_body, petsc_objs, struct)

    # Replace target with a PETScArray inside the matvec callback function.
    # NOTE: This is necessary because in the matrix-free algorithm, you need to provide
    # the application of the linear operator on some vector (which is not the target field
    # generated by the user).
    # mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed} if target else {}
    # matvec_callback = Uxreplace(mapper).visit(matvec_callback)

    # Replace the part of the iet that contains the action with
    # the corresponding PETSc calls.
    # TODO: Eventually, this will be extended to deal with multiple different
    # 'actions' associated with different equations to solve.
    # action_mapper = {with_action: solve_body} if with_action else {}
    # iet = Transformer(action_mapper).visit(iet)

    return iet, {}


def build_petsc_objects(target):
    # TODO: Eventually, the objects built will be based
    # on the number of different PETSc equations present etc.

    return {'A_matfree': Mat(name='A_matfree'),
            'xvec': Vec(name='xvec'),
            'local_xvec': Vec(name='local_xvec', liveness='eager'),
            'local_yvec': Vec(name='local_yvec', liveness='eager'),
            'yvec': Vec(name='yvec'),
            'da': DM(name='da', liveness='eager'),
            'x': Vec(name='x'),
            'err': PetscErrorCode(name='err'),
            'size': PetscMPIInt(name='size'),
            'xvec_tmp': (PETScArray(name='xvec_tmp', dtype=target.dtype,
                                    dimensions=target.dimensions,
                                    shape=target.shape,
                                    liveness='eager'))}


def build_struct(action):
    # Build the struct
    tmp1 = FindSymbols('basics').visit(action)
    tmp2 = FindSymbols('dimensions|indexedbases').visit(action)
    usr_ctx = [symb for symb in tmp1 if symb not in tmp2]
    return PETScStruct('ctx', usr_ctx)


def build_matvec_body(action, objs, struct, expr_target):

    # TODO: Create class type that generates this line
    func_begin_user = c.Line('PetscFunctionBeginUser;')

    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                          arguments=[objs['A_matfree'],
                                                     Byref(struct)])])

    mat_get_dm = Call('PetscCall', [Call('MatGetDM',
                                         arguments=[objs['A_matfree'],
                                                    Byref(objs['da'])])])

    dm_get_local_xvec = Call('PetscCall', [Call('MatGetLocalVector',
                                                arguments=[objs['da'],
                                                           Byref(objs['local_xvec'])])])

    dm_global_local_begin = Call('PetscCall', [Call('DMGlobalToLocalBegin',
                                                    arguments=[objs['da'],
                                                               objs['xvec'],
                                                               'INSERT_VALUES',
                                                               objs['local_xvec']])])

    dm_global_local_end = Call('PetscCall', [Call('DMGlobalToLocalEnd',
                                                  arguments=[objs['da'],
                                                             objs['xvec'],
                                                             'INSERT_VALUES',
                                                             objs['local_xvec']])])

    dm_vec_get_array_read = Call('PetscCall',
                                 [Call('DMDAVecGetArrayRead',
                                       arguments=[objs['da'],
                                                  objs['local_xvec'],
                                                  Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_get_array = Call('PetscCall',
                            [Call('DMDAVecGetArray',
                                  arguments=[objs['da'],
                                             objs['yvec'],
                                             Byref(expr_target[0].write._C_symbol)])])

    dm_vec_restore_array_read = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArrayRead', arguments=[objs['da'],
                                                    objs['local_xvec'],
                                                    Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_restore_array = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArray', arguments=[objs['da'],
                                                objs['yvec'],
                                                Byref(expr_target[0].write._C_symbol)])])

    dm_restore_local_vec = Call(
        'PetscCall',
        [Call('DMRestoreLocalVector', arguments=[objs['da'],
                                                 Byref(objs['local_xvec'])])])

    func_return = Call('PetscFunctionReturn', arguments=[0])

    body = List(body=[func_begin_user,
                      Definition(struct),
                      get_context,
                      mat_get_dm,
                      dm_get_local_xvec,
                      dm_global_local_begin,
                      dm_global_local_end,
                      dm_vec_get_array_read,
                      dm_vec_get_array,
                      action,
                      dm_vec_restore_array_read,
                      dm_vec_restore_array,
                      dm_restore_local_vec,
                      func_return])

    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)
    return body


def build_solve(matvec_body, petsc_objs, struct):

    # TODO: Create class type that generates this line
    func_begin_user = c.Line('PetscFunctionBeginUser;')

    # TODO: This will all change when it is working with MPI
    initialize = Call('PetscCall', [Call('PetscInitialize',
                                         arguments=['NULL', 'NULL',
                                                    'NULL', 'NULL'])])

    call_mpi = Call('PetscCallMPI', [Call('MPI_Comm_size',
                                          arguments=['PETSC_COMM_WORLD',
                                                     Byref(petsc_objs['size'])])])

    # TODO: Create DM based on the dimensions of the target field
    dm_create = Call('PetscCall', [Call('DMCreate2d',
                                        arguments=['PETSC_COMM_SELF',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_STENCIL_STAR',
                                                   11, 11,
                                                   'PETSC_DECIDE',
                                                   'PETSC_DECIDE',
                                                   1, 1,
                                                   'NULL', 'NULL',
                                                   petsc_objs['da']])])

    dm_set_from_options = Call('PetscCall', [Call('DMSetFromOptions',
                                                  arguments=[petsc_objs['da']])])

    dm_setup = Call('PetscCall', [Call('DMSetUp', arguments=[petsc_objs['da']])])

    dm_set_mattype = Call('PetscCall', [Call('DMSetMatType',
                                             arguments=[petsc_objs['da'],
                                                        'MATSHELL'])])

    dm_create_mat = Call('PetscCall', [Call('DMCreateMatrix',
                                            arguments=[petsc_objs['da'],
                                                       Byref(petsc_objs['A_matfree'])])])

    matvec_callback = Callable('MyMatShellMult',
                               matvec_body,
                               retval=petsc_objs['err'],
                               parameters=(petsc_objs['A_matfree'],
                                           petsc_objs['xvec'],
                                           petsc_objs['yvec']))

    matvec_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[petsc_objs['A_matfree'],
                                                          'MATOP_MULT',
                                                          Callback(matvec_callback.name,
                                                                   'void', 'void')])])

    set_context = Call('PetscCall', [Call('MatShellSetContext',
                                          arguments=[petsc_objs['A_matfree'],
                                                     struct])])

    body = List(body=[func_begin_user,
                      initialize,
                      call_mpi,
                      dm_create,
                      dm_set_from_options,
                      dm_setup,
                      dm_set_mattype,
                      dm_create_mat,
                      matvec_operation,
                      set_context])

    return matvec_callback, body
