from devito.passes.iet.engine import iet_pass
from devito.ir.iet import (List, Callable, Call, Transformer,
                           Callback, Definition, Uxreplace, FindSymbols,
                           Iteration, MapNodes, ActionExpr)
from devito.types.petsc import Mat, Vec, DM, PetscErrorCode, PETScStruct, PETScArray
from devito.symbolics import FieldFromPointer, Byref


__all__ = ['lower_petsc']


@iet_pass
def lower_petsc(iet, **kwargs):
    # NOTE: Currently only considering the case when opt='noop'. This
    # does not deal with the Temp Expressions generated when opt is not set
    # to 'noop' etc.

    # Find the largest Iteration loop containing the Action
    iter_expr_mapper = MapNodes(Iteration, ActionExpr).visit(iet)
    with_action = next(iter(iter_expr_mapper), [])

    # Find the original target (i.e the field we are solving for)
    # TODO: Extend to multiple targets but for now assume
    # we are only solving 1 equation via PETSc.
    target = next(iter(iter_expr_mapper.values()), None)
    if target:
        target = [i for i in target[0].functions if not isinstance(i, PETScArray)][0]

    # Build PETSc objects required for the solve.
    petsc_objs = build_petsc_objects(target)

    # Build the struct that is needed within the matvec callback
    struct = build_struct(with_action)

    # Build the body of the matvec callback
    matvec_body = build_matvec_body(with_action, petsc_objs, struct)

    matvec_callback, solve_body = build_solve(matvec_body, petsc_objs, struct)

    # Replace target with a PETScArray inside the matvec callback function.
    # NOTE: This is necessary because in the matrix-free algorithm, you need to provide
    # the application of the linear operator on some vector (which is not the target field
    # generated by the user).
    mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed} if target else {}
    matvec_callback = Uxreplace(mapper).visit(matvec_callback)

    # Replace the part of the iet that contains the action with
    # the corresponding PETSc calls.
    # TODO: Eventually, this will be extended to deal with multiple different
    # 'actions' associated with different equations to solve.
    action_mapper = {with_action: solve_body} if with_action else {}
    iet = Transformer(action_mapper).visit(iet)

    return iet, {'efuncs': [matvec_callback]} if with_action else {}


def build_petsc_objects(target):
    # TODO: Eventually, the objects built will be based
    # on the number of different PETSc equations present etc.

    xvec_tmp = (PETScArray(name='xvec_tmp', dtype=target.dtype,
                           dimensions=target.dimensions,
                           shape=target.shape, liveness='eager') if target else None)

    return {'A_matfree': Mat(name='A_matfree'),
            'xvec': Vec(name='xvec'),
            'yvec': Vec(name='yvec'),
            'da': DM(name='da'),
            'x': Vec(name='x'),
            'err': PetscErrorCode(name='err'),
            'xvec_tmp': xvec_tmp}


def build_struct(action):
    # Build the struct
    tmp1 = FindSymbols('basics').visit(action)
    tmp2 = FindSymbols('dimensions|indexedbases').visit(action)
    usr_ctx = [symb for symb in tmp1 if symb not in tmp2]
    return PETScStruct('ctx', usr_ctx)


def build_matvec_body(action, objs, struct):
    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                          arguments=[objs['A_matfree'],
                                                     Byref(struct.name)])])
    body = List(body=[Definition(struct),
                      get_context,
                      action])
    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)
    return body


def build_solve(matvec_body, petsc_objs, struct):

    matvec_callback = Callable('MyMatShellMult',
                               matvec_body,
                               retval=petsc_objs['err'],
                               parameters=(petsc_objs['A_matfree'],
                                           petsc_objs['xvec'],
                                           petsc_objs['yvec']))

    matvec_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[petsc_objs['A_matfree'],
                                                          'MATOP_MULT',
                                                          Callback(matvec_callback.name,
                                                                   'void', 'void')])])

    set_context = Call('PetscCall', [Call('MatShellSetContext',
                                          arguments=[petsc_objs['A_matfree'],
                                                     struct])])

    body = List(body=[set_context,
                      matvec_operation])

    return matvec_callback, body
