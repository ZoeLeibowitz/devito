from devito.passes.iet.engine import iet_pass
from devito.ir.iet import (List, Callable, Call, Transformer,
                           Callback, Definition, Uxreplace, FindSymbols,
                           Iteration, MapNodes, ActionExpr, RHSExpr,
                           FindNodes, Expression, DummyExpr)
from devito.types.petsc import (Mat, Vec, DM, PetscErrorCode, PETScStruct,
                                PETScArray, PetscMPIInt, KSP, PC)
from devito.symbolics import FieldFromPointer, Byref
import cgen as c
from devito.ir.equations.equation import OpSetUpRHS, OpLinSolve


__all__ = ['lower_petsc']


@iet_pass
def lower_petsc(iet, **kwargs):
    # NOTE: Currently only considering the case when opt='noop'. This
    # does not deal with the Temp Expressions generated when opt is not set
    # to 'noop' etc.

    # Find the largest Iteration loop containing the Action
    iter_expr_mapper = MapNodes(Iteration, ActionExpr).visit(iet)

    if bool(iter_expr_mapper):

        # Find the original target (i.e the field we are solving for)
        # TODO: Extend to multiple targets but for now assume
        # we are only solving 1 equation via PETSc.
        action_expr = next(iter(iter_expr_mapper.values()))
        # from IPython import embed; embed()
        target = [i for i in action_expr[0].functions if not isinstance(i, PETScArray)][0]

        # Build PETSc objects required for the solve.
        petsc_objs = build_petsc_objects(target)

        # Extract the largest iteration loop containing the action expression
        iteration = next(iter(iter_expr_mapper))

        # Build the struct that is needed within the matvec callback
        struct = build_struct(iteration)

        # Build the body of the matvec callback
        matvec_body = build_matvec_body(iteration, petsc_objs, struct, action_expr)

        matvec_callback, solve_body = build_solve(matvec_body, petsc_objs, struct)

        # Replace target with a PETScArray inside the matvec callback function.
        # NOTE: This is necessary because in the matrix-free algorithm, you need
        # to provide the application of the linear operator on some vector
        # (which is not the target field generated by the user).
        mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed}
        matvec_callback = Uxreplace(mapper).visit(matvec_callback)

        # Replace the part of the iet that contains the action with
        # the corresponding PETSc calls.
        # TODO: Eventually, this will be extended to deal with multiple different
        # 'actions' associated with different equations to solve.
        action_mapper = {iteration: solve_body}
        iet = Transformer(action_mapper).visit(iet)

        # Replace SetUpRHSExpr dummy with appropriate PETSc calls
        # If we have an action, we have a corresponding SetUpRHSExpr

        iter_rhs_mapper = MapNodes(Iteration, RHSExpr).visit(iet)
        # Search the largest iteration loop that contains the rhs
        # expression for any dummys e.g replace exprs with operation=SetUpRHS
        # with the appropriate PETSc calls.
        iteration_rhs = next(iter(iter_rhs_mapper))
        exprs = FindNodes(Expression).visit(iteration_rhs)

        rhs_expr = [expr for expr in exprs if isinstance(expr, RHSExpr)]
        b_tmp = [i for i in rhs_expr[0].functions if isinstance(i, PETScArray)][0]

        # Replace the dummyeq1 with PETSc calls to set up RHS
        find_setuprhs = [i for i in exprs if i.operation is OpSetUpRHS]
        setup_rhs = build_rhs_setup(petsc_objs, b_tmp)
        # iet = Transformer({find_setuprhs[0]: setup_rhs}).visit(iet)

        # Replace the dummyeq2 with PETSc calls to execute the linear solve
        find_linsolve = [i for i in exprs if i.operation is OpLinSolve]
        x_tmp = PETScArray(name='xvec_tmp', dtype=target.dtype,
                           dimensions=target.dimensions,
                           shape=target.shape,
                           liveness='eager')

        from itertools import islice
        iteration_spatial_rhs = next(islice(iter_rhs_mapper, 1, 2), None)
        # THIS IS OBVIOUSLY TEMPORARY: NEED TO THINK. MAYBE I WILL NOT EVEN NEED
        # THE MAPPING AND X_TMP ARRAY
        indices = (target.dimensions[0]+2, target.dimensions[1]+2)
        sol_expr = DummyExpr(target.indexify(indices=indices), x_tmp.indexify())
        sol_mapping = Transformer({rhs_expr[0]: sol_expr}).visit(iteration_spatial_rhs)
        linsolve = execute_solve(petsc_objs, b_tmp, sol_mapping, x_tmp)

        iet = Transformer({find_linsolve[0]: linsolve,
                           find_setuprhs[0]: setup_rhs}).visit(iet)

        return iet, {'efuncs': [matvec_callback]}

    return iet, {}


def build_petsc_objects(target):
    # TODO: Eventually, the objects built will be based
    # on the number of different PETSc equations present etc.

    return {'A_matfree': Mat(name='A_matfree'),
            'xvec': Vec(name='xvec'),
            'local_xvec': Vec(name='local_xvec', liveness='eager'),
            'yvec': Vec(name='yvec'),
            'da': DM(name='da', liveness='eager'),
            'x': Vec(name='x'),
            'b': Vec(name='b'),
            'ksp': KSP(name='ksp'),
            'pc': PC(name='pc'),
            'err': PetscErrorCode(name='err'),
            'size': PetscMPIInt(name='size'),
            'xvec_tmp': (PETScArray(name='xvec_tmp', dtype=target.dtype,
                                    dimensions=target.dimensions,
                                    shape=target.shape,
                                    liveness='eager'))}


def build_struct(action):
    # Build the struct
    tmp1 = FindSymbols('basics').visit(action)
    tmp2 = FindSymbols('dimensions|indexedbases').visit(action)
    usr_ctx = [symb for symb in tmp1 if symb not in tmp2]
    return PETScStruct('ctx', usr_ctx)


def build_matvec_body(action, objs, struct, expr_target):

    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                          arguments=[objs['A_matfree'],
                                                     Byref(struct)])])

    mat_get_dm = Call('PetscCall', [Call('MatGetDM',
                                         arguments=[objs['A_matfree'],
                                                    Byref(objs['da'])])])

    dm_get_local_xvec = Call('PetscCall', [Call('MatGetLocalVector',
                                                arguments=[objs['da'],
                                                           Byref(objs['local_xvec'])])])

    dm_global_local_begin = Call('PetscCall', [Call('DMGlobalToLocalBegin',
                                                    arguments=[objs['da'],
                                                               objs['xvec'],
                                                               'INSERT_VALUES',
                                                               objs['local_xvec']])])

    dm_global_local_end = Call('PetscCall', [Call('DMGlobalToLocalEnd',
                                                  arguments=[objs['da'],
                                                             objs['xvec'],
                                                             'INSERT_VALUES',
                                                             objs['local_xvec']])])

    dm_vec_get_array_read = Call('PetscCall',
                                 [Call('DMDAVecGetArrayRead',
                                       arguments=[objs['da'],
                                                  objs['local_xvec'],
                                                  Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_get_array = Call('PetscCall',
                            [Call('DMDAVecGetArray',
                                  arguments=[objs['da'],
                                             objs['yvec'],
                                             Byref(expr_target[0].write._C_symbol)])])

    dm_vec_restore_array_read = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArrayRead', arguments=[objs['da'],
                                                    objs['local_xvec'],
                                                    Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_restore_array = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArray', arguments=[objs['da'],
                                                objs['yvec'],
                                                Byref(expr_target[0].write._C_symbol)])])

    dm_restore_local_vec = Call(
        'PetscCall',
        [Call('DMRestoreLocalVector', arguments=[objs['da'],
                                                 Byref(objs['local_xvec'])])])

    func_return = Call('PetscFunctionReturn', arguments=[0])

    body = List(header=c.Line('PetscFunctionBeginUser;'),
                body=[Definition(struct),
                      get_context,
                      mat_get_dm,
                      dm_get_local_xvec,
                      dm_global_local_begin,
                      dm_global_local_end,
                      dm_vec_get_array_read,
                      dm_vec_get_array,
                      action,
                      dm_vec_restore_array_read,
                      dm_vec_restore_array,
                      dm_restore_local_vec,
                      func_return])

    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)
    return body


def build_solve(matvec_body, objs, struct):
    # TODO: Many of these args will be set based on user provided args in
    # PETScSolve

    # TODO: Create class type that generates this line
    func_begin_user = c.Line('PetscFunctionBeginUser;')

    # TODO: This will all change when it is working with MPI
    initialize = Call('PetscCall', [Call('PetscInitialize',
                                         arguments=['NULL', 'NULL',
                                                    'NULL', 'NULL'])])

    call_mpi = Call('PetscCallMPI', [Call('MPI_Comm_size',
                                          arguments=['PETSC_COMM_WORLD',
                                                     Byref(objs['size'])])])

    # TODO: Create DM based on the dimensions of the target field
    dm_create = Call('PetscCall', [Call('DMCreate2d',
                                        arguments=['PETSC_COMM_SELF',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_STENCIL_STAR',
                                                   11, 11,
                                                   'PETSC_DECIDE',
                                                   'PETSC_DECIDE',
                                                   1, 1,
                                                   'NULL', 'NULL',
                                                   objs['da']])])

    dm_set_from_options = Call('PetscCall', [Call('DMSetFromOptions',
                                                  arguments=[objs['da']])])

    dm_setup = Call('PetscCall', [Call('DMSetUp', arguments=[objs['da']])])

    dm_set_mattype = Call('PetscCall', [Call('DMSetMatType',
                                             arguments=[objs['da'],
                                                        'MATSHELL'])])

    dm_create_mat = Call('PetscCall', [Call('DMCreateMatrix',
                                            arguments=[objs['da'],
                                                       Byref(objs['A_matfree'])])])

    matvec_callback = Callable('MyMatShellMult',
                               matvec_body,
                               retval=objs['err'],
                               parameters=(objs['A_matfree'],
                                           objs['xvec'],
                                           objs['yvec']))

    matvec_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[objs['A_matfree'],
                                                          'MATOP_MULT',
                                                          Callback(matvec_callback.name,
                                                                   'void', 'void')])])

    set_context = Call('PetscCall', [Call('MatShellSetContext',
                                          arguments=[objs['A_matfree'],
                                                     struct])])

    ksp_create = Call('PetscCall', [Call('KSPCreate',
                                         arguments=['PETSC_COMM_SELF',
                                                    Byref(objs['ksp'])])])

    ksp_set_operators = Call('PetscCall', [Call('KSPSetOperators',
                                                arguments=[objs['ksp'],
                                                           objs['A_matfree'],
                                                           objs['A_matfree']])])

    ksp_set_tol = Call('PetscCall', [Call('KSPSetTolerances',
                                          arguments=[objs['ksp'],
                                                     '1.e-7',
                                                     'PETSC_DEFAULT',
                                                     'PETSC_DEFAULT',
                                                     'PETSC_DEFAULT'])])

    ksp_set_type = Call('PetscCall', [Call('KSPSetType',
                                           arguments=[objs['ksp'],
                                                      'KSPGMRES'])])

    ksp_get_pc = Call('PetscCall', [Call('KSPGetPC',
                                         arguments=[objs['ksp'],
                                                    Byref(objs['pc'])])])

    pc_set_type = Call('PetscCall', [Call('PCSetType',
                                          arguments=[objs['pc'],
                                                     'PCJACOBI'])])

    pc_jacobi_set_type = Call('PetscCall', [Call('PCSetType',
                                                 arguments=[objs['pc'],
                                                            'PC_JACOBI_DIAGONAL'])])

    ksp_set_from_opts = Call('PetscCall', [Call('KSPSetFromOptions',
                                                arguments=[objs['ksp']])])

    body = List(body=[func_begin_user,
                      initialize,
                      call_mpi,
                      dm_create,
                      dm_set_from_options,
                      dm_setup,
                      dm_set_mattype,
                      dm_create_mat,
                      matvec_operation,
                      set_context,
                      ksp_create,
                      ksp_set_operators,
                      ksp_set_tol,
                      ksp_set_type,
                      ksp_get_pc,
                      pc_set_type,
                      pc_jacobi_set_type,
                      ksp_set_from_opts])

    return matvec_callback, body


def build_rhs_setup(objs, b_tmp):

    dm_create_global_vec_x = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['x'])])])
    dm_create_global_vec_b = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['b'])])])

    dm_vec_get_array = Call('PetscCall', [Call('DMDAVecGetArray',
                                               arguments=[objs['da'],
                                                          objs['b'],
                                                          Byref(b_tmp)])])

    body = List(body=[dm_create_global_vec_x,
                      dm_create_global_vec_b,
                      dm_vec_get_array])

    return body


def execute_solve(objs, b_tmp, sol_mapping, x_tmp):

    dm_vec_restore_array_b = Call('PetscCall', [Call('DMDAVecRestoreArray',
                                                     arguments=[objs['da'],
                                                                objs['b'],
                                                                Byref(b_tmp)])])

    ksp_solve = Call('PetscCall', [Call('KSPSolve',
                                        arguments=[objs['ksp'],
                                                   objs['b'],
                                                   objs['x']])])

    dm_vec_get_array_x = Call('PetscCall', [Call('DMDAVecGetArray',
                                                 arguments=[objs['da'],
                                                            objs['x'],
                                                            Byref(x_tmp)])])

    dm_vec_restore_array_x = Call('PetscCall', [Call('DMDAVecRestoreArray',
                                                     arguments=[objs['da'],
                                                                objs['x'],
                                                                Byref(x_tmp)])])

    # TODO: DESTROY OBJECTS

    body = List(body=[dm_vec_restore_array_b,
                      ksp_solve,
                      dm_vec_get_array_x,
                      sol_mapping,
                      dm_vec_restore_array_x])

    return body
