from devito.passes.iet.engine import iet_pass
from devito.ir.iet import (List, Callable, Call, Transformer,
                           Callback, Definition, Uxreplace, FindSymbols,
                           Iteration, MapNodes, ActionExpr, RHSExpr,
                           FindNodes, Expression)
from devito.types.petsc import (Mat, Vec, DM, PetscErrorCode, PETScStruct,
                                PETScArray, PetscMPIInt)
from devito.symbolics import FieldFromPointer, Byref
import cgen as c
from devito.ir.equations.equation import OpSetUpRHS


__all__ = ['lower_petsc']


@iet_pass
def lower_petsc(iet, **kwargs):
    # NOTE: Currently only considering the case when opt='noop'. This
    # does not deal with the Temp Expressions generated when opt is not set
    # to 'noop' etc.

    # Find the largest Iteration loop containing the Action
    iter_expr_mapper = MapNodes(Iteration, ActionExpr).visit(iet)

    if bool(iter_expr_mapper):

        # Find the original target (i.e the field we are solving for)
        # TODO: Extend to multiple targets but for now assume
        # we are only solving 1 equation via PETSc.
        action_expr = next(iter(iter_expr_mapper.values()))
        # from IPython import embed; embed()
        target = [i for i in action_expr[0].functions if not isinstance(i, PETScArray)][0]

        # Build PETSc objects required for the solve.
        petsc_objs = build_petsc_objects(target)

        # Extract the largest iteration loop containing the action expression
        iteration = next(iter(iter_expr_mapper))

        # Build the struct that is needed within the matvec callback
        struct = build_struct(iteration)

        # Build the body of the matvec callback
        matvec_body = build_matvec_body(iteration, petsc_objs, struct, action_expr)

        matvec_callback, solve_body = build_solve(matvec_body, petsc_objs, struct)

        # Replace target with a PETScArray inside the matvec callback function.
        # NOTE: This is necessary because in the matrix-free algorithm, you need
        # to provide the application of the linear operator on some vector
        # (which is not the target field generated by the user).
        mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed}
        matvec_callback = Uxreplace(mapper).visit(matvec_callback)

        # Replace the part of the iet that contains the action with
        # the corresponding PETSc calls.
        # TODO: Eventually, this will be extended to deal with multiple different
        # 'actions' associated with different equations to solve.
        action_mapper = {iteration: solve_body}
        iet = Transformer(action_mapper).visit(iet)

        # Replace SetUpRHSExpr dummy with appropriate PETSc calls
        # If we have an action, we have a corresponding SetUpRHSExpr

        iter_rhs_mapper = MapNodes(Iteration, RHSExpr).visit(iet)
        # Search the largest iteration loop that contains the rhs
        # expression for any dummys e.g replace exprs with operation=SetUpRHS
        # with the appropriate PETSc calls.
        iteration_rhs = next(iter(iter_rhs_mapper))
        find_setuprhs = FindNodes(Expression).visit(iteration_rhs)
        find_setuprhs = [i for i in find_setuprhs if i.operation is OpSetUpRHS]
        setup_rhs = build_rhs_setup(petsc_objs)
        iet = Transformer({find_setuprhs[0]: setup_rhs}).visit(iet)

        return iet, {'efuncs': [matvec_callback]}

    return iet, {}


def build_petsc_objects(target):
    # TODO: Eventually, the objects built will be based
    # on the number of different PETSc equations present etc.

    return {'A_matfree': Mat(name='A_matfree'),
            'xvec': Vec(name='xvec'),
            'local_xvec': Vec(name='local_xvec', liveness='eager'),
            'yvec': Vec(name='yvec'),
            'da': DM(name='da', liveness='eager'),
            'x': Vec(name='x'),
            'b': Vec(name='b'),
            'err': PetscErrorCode(name='err'),
            'size': PetscMPIInt(name='size'),
            'xvec_tmp': (PETScArray(name='xvec_tmp', dtype=target.dtype,
                                    dimensions=target.dimensions,
                                    shape=target.shape,
                                    liveness='eager'))}


def build_struct(action):
    # Build the struct
    tmp1 = FindSymbols('basics').visit(action)
    tmp2 = FindSymbols('dimensions|indexedbases').visit(action)
    usr_ctx = [symb for symb in tmp1 if symb not in tmp2]
    return PETScStruct('ctx', usr_ctx)


def build_matvec_body(action, objs, struct, expr_target):

    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                          arguments=[objs['A_matfree'],
                                                     Byref(struct)])])

    mat_get_dm = Call('PetscCall', [Call('MatGetDM',
                                         arguments=[objs['A_matfree'],
                                                    Byref(objs['da'])])])

    dm_get_local_xvec = Call('PetscCall', [Call('MatGetLocalVector',
                                                arguments=[objs['da'],
                                                           Byref(objs['local_xvec'])])])

    dm_global_local_begin = Call('PetscCall', [Call('DMGlobalToLocalBegin',
                                                    arguments=[objs['da'],
                                                               objs['xvec'],
                                                               'INSERT_VALUES',
                                                               objs['local_xvec']])])

    dm_global_local_end = Call('PetscCall', [Call('DMGlobalToLocalEnd',
                                                  arguments=[objs['da'],
                                                             objs['xvec'],
                                                             'INSERT_VALUES',
                                                             objs['local_xvec']])])

    dm_vec_get_array_read = Call('PetscCall',
                                 [Call('DMDAVecGetArrayRead',
                                       arguments=[objs['da'],
                                                  objs['local_xvec'],
                                                  Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_get_array = Call('PetscCall',
                            [Call('DMDAVecGetArray',
                                  arguments=[objs['da'],
                                             objs['yvec'],
                                             Byref(expr_target[0].write._C_symbol)])])

    dm_vec_restore_array_read = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArrayRead', arguments=[objs['da'],
                                                    objs['local_xvec'],
                                                    Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_restore_array = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArray', arguments=[objs['da'],
                                                objs['yvec'],
                                                Byref(expr_target[0].write._C_symbol)])])

    dm_restore_local_vec = Call(
        'PetscCall',
        [Call('DMRestoreLocalVector', arguments=[objs['da'],
                                                 Byref(objs['local_xvec'])])])

    func_return = Call('PetscFunctionReturn', arguments=[0])

    body = List(header=c.Line('PetscFunctionBeginUser;'),
                body=[Definition(struct),
                      get_context,
                      mat_get_dm,
                      dm_get_local_xvec,
                      dm_global_local_begin,
                      dm_global_local_end,
                      dm_vec_get_array_read,
                      dm_vec_get_array,
                      action,
                      dm_vec_restore_array_read,
                      dm_vec_restore_array,
                      dm_restore_local_vec,
                      func_return])

    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)
    return body


def build_solve(matvec_body, petsc_objs, struct):

    # TODO: Create class type that generates this line
    func_begin_user = c.Line('PetscFunctionBeginUser;')

    # TODO: This will all change when it is working with MPI
    initialize = Call('PetscCall', [Call('PetscInitialize',
                                         arguments=['NULL', 'NULL',
                                                    'NULL', 'NULL'])])

    call_mpi = Call('PetscCallMPI', [Call('MPI_Comm_size',
                                          arguments=['PETSC_COMM_WORLD',
                                                     Byref(petsc_objs['size'])])])

    # TODO: Create DM based on the dimensions of the target field
    dm_create = Call('PetscCall', [Call('DMCreate2d',
                                        arguments=['PETSC_COMM_SELF',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_BOUNDARY_MIRROR',
                                                   'DMDA_STENCIL_STAR',
                                                   11, 11,
                                                   'PETSC_DECIDE',
                                                   'PETSC_DECIDE',
                                                   1, 1,
                                                   'NULL', 'NULL',
                                                   petsc_objs['da']])])

    dm_set_from_options = Call('PetscCall', [Call('DMSetFromOptions',
                                                  arguments=[petsc_objs['da']])])

    dm_setup = Call('PetscCall', [Call('DMSetUp', arguments=[petsc_objs['da']])])

    dm_set_mattype = Call('PetscCall', [Call('DMSetMatType',
                                             arguments=[petsc_objs['da'],
                                                        'MATSHELL'])])

    dm_create_mat = Call('PetscCall', [Call('DMCreateMatrix',
                                            arguments=[petsc_objs['da'],
                                                       Byref(petsc_objs['A_matfree'])])])

    matvec_callback = Callable('MyMatShellMult',
                               matvec_body,
                               retval=petsc_objs['err'],
                               parameters=(petsc_objs['A_matfree'],
                                           petsc_objs['xvec'],
                                           petsc_objs['yvec']))

    matvec_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[petsc_objs['A_matfree'],
                                                          'MATOP_MULT',
                                                          Callback(matvec_callback.name,
                                                                   'void', 'void')])])

    set_context = Call('PetscCall', [Call('MatShellSetContext',
                                          arguments=[petsc_objs['A_matfree'],
                                                     struct])])

    body = List(body=[func_begin_user,
                      initialize,
                      call_mpi,
                      dm_create,
                      dm_set_from_options,
                      dm_setup,
                      dm_set_mattype,
                      dm_create_mat,
                      matvec_operation,
                      set_context])

    return matvec_callback, body


def build_rhs_setup(objs):

    dm_create_global_vec_x = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['x'])])])
    dm_create_global_vec_b = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['b'])])])
    body = List(body=[dm_create_global_vec_x,
                      dm_create_global_vec_b])

    return body
