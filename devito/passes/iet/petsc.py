from devito.passes.iet.engine import iet_pass
from devito.ir.iet import (List, Callable, Call, Transformer,
                           Callback, Definition, Uxreplace, FindSymbols,
                           Iteration, MapNodes, ActionExpr, RHSExpr, SolutionExpr,
                           FindNodes, Expression, DummyExpr, PETScDumExpr,
                           retrieve_iteration_tree, filter_iterations)
from devito.types.petsc import (Mat, Vec, DM, PetscErrorCode, PETScStruct,
                                PETScArray, PetscMPIInt, KSP, PC)
from devito.symbolics import FieldFromPointer, Byref
import cgen as c
from devito.ir.equations.equation import OpPreStencil
from functools import reduce


__all__ = ['lower_petsc']


# @iet_pass
# def lower_petsc(iet, **kwargs):
#     # NOTE: Currently only considering the case when opt='noop'. This
#     # does not deal with the Temp Expressions generated when opt is not set
#     # to 'noop' etc.

#     # Find Iteration containing the ActionExpr
#     iter_ae_mapper = MapNodes(Iteration, ActionExpr, 'groupby').visit(iet)
#     # from IPython import embed; embed()
#     if iter_ae_mapper:

#         # TODO: Extend to multiple targets but for now assume
#         # we are only solving 1 equation via PETSc.
#         for iter, ae in iter_ae_mapper.items():
#             target = [i for i in ae[0].functions if not isinstance(i, PETScArray)][0]

#             # Build PETSc objects required for the solve.
#             petsc_objs = build_petsc_objects(target)

#             # Build struct from largest iteration loop, required for the
#             # callback functions.
#             struct = build_struct(iter[0])
#             # from IPython import embed; embed()
#             # Build the body of the matvec callback
#             # rebuild_matvec = iter[0]._rebuild(iter[-1]._rebuild(nodes=ae[0]))
#             matvec_body = build_matvec_body(iter[0], petsc_objs, struct, ae[0])

#             # Build the body of the preconditioner callback
#             tmp = FindNodes(Expression).visit(iter[0])
#             pre_stencil = [i for i in tmp if i.operation is OpPreStencil]
#             # rebuild_pre = iter[0]._rebuild(iter[-1]._rebuild(nodes=pre_stencil[0]))
#             pre_body = build_pre_body(iter[0], petsc_objs, struct, ae[0])

#             matvec_callback, pre_callback, solve_body = build_solve(matvec_body, pre_body,
#                                                                     petsc_objs, struct,
#                                                                     target)

#             # Replace target with a PETScArray inside the matvec callback function.
#             # NOTE: This is necessary because in the matrix-free algorithm, you need
#             # to provide the application of the linear operator on some vector
#             # (which is not the target field generated by the user).
#             mapper = {target.indexed: petsc_objs['xvec_tmp'].indexed}
#             matvec_callback = Uxreplace(mapper).visit(matvec_callback)
#             pre_callback = Uxreplace(mapper).visit(pre_callback)

#             # Replace the part of the iet that contains the action with
#             # the corresponding PETSc calls.
#             # TODO: Eventually, this will be extended to deal with multiple different
#             # 'actions' associated with different equations to solve.
#             action_mapper = {iter[0]: solve_body}
#             iet = Transformer(action_mapper).visit(iet)

#             iter_rhs_mapper = MapNodes(Iteration, RHSExpr, 'groupby').visit(iet)
   
#             for iter_rhs, rhs_expr in iter_rhs_mapper.items():


#                 setup_rhs = build_rhs_setup(petsc_objs, rhs_expr[0].write)

#                 ##########################################################################
#                 # THIS IS TEMPORARY: NEED TO THINK. MAYBE I WILL NOT EVEN NEED
#                 # THE MAPPING AND X_TMP ARRAY
#                 x_tmp = PETScArray(name='xvec_tmp', dtype=target.dtype,
#                                    dimensions=target.dimensions,
#                                    shape=target.shape, liveness='eager')
#                 indices = tuple(d + target.space_order for d in target.space_dimensions)
#                 sol_expr = DummyExpr(target.indexify(indices=indices), x_tmp.indexify())

#                 mapping_iters = [lambda ex, d=d: Iteration
#                                  (ex, d, (d.symbolic_min, d.symbolic_max, 1))
#                                  for d in target.dimensions[::-1]]

#                 petsc_2_dev = reduce(lambda nested, mapping_iter: mapping_iter(nested),
#                                      mapping_iters, sol_expr)
#                 #########################################################################

#                 linsolve = execute_solve(petsc_objs, rhs_expr[0].write,
#                                          petsc_2_dev, x_tmp)

#                 # iter_rhs[1] is just the spatial loop. Is there a way of just
#                 # obtaining the spatial loop not time?
#                 iet = Transformer({iter_rhs[1]: List(body=[setup_rhs, iter_rhs[1], linsolve])}).visit(iet)

#             # drop any PETScDummys
#             dummy_mapper = MapNodes(Iteration, PETScDumExpr, 'groupby').visit(iet)
#             for iter_dummy, dummy in dummy_mapper.items():
#                 # It is 1 because it is within the time loop. Edit this.
#                 iet = Transformer({dummy[0]: None}).visit(iet)


#             # TODO: Obviously it won't be like this.
#             kwargs['compiler'].add_include_dirs('/home/zl5621/petsc/include')
#             path = '/home/zl5621/petsc/arch-linux-c-debug/include'
#             kwargs['compiler'].add_include_dirs(path)
#             kwargs['compiler'].add_libraries('petsc')
#             libdir = '/home/zl5621/petsc/arch-linux-c-debug/lib'
#             kwargs['compiler'].add_library_dirs(libdir)
#             kwargs['compiler'].add_ldflags('-Wl,-rpath,%s' % libdir)

#             return iet, {'efuncs': [matvec_callback, pre_callback],
#                             'includes': ['petscksp.h', 'petscdmda.h']}

#     return iet, {}


@iet_pass
def lower_petsc(iet, **kwargs):
    # NOTE: Currently only considering the case when opt='noop'. This
    # does not deal with the Temp Expressions generated when opt is not set
    # to 'noop' etc.

    # Immediately drop all PETScDummyExprs.
    iet = drop_dummies(iet)

    # Generate the one off PETSc calls that do not need to be duplicated in the case of
    # multiple PETScSolves e.g PetscInitialize.
    setup = petsc_setup()

    # Figure out how many PETScSolves were passed to the Operator.
    iter_sol_mapper = MapNodes(Iteration, SolutionExpr, 'groupby').visit(iet)
    
    for iter, (sol,) in iter_sol_mapper.items():

        # from IPython import embed; embed()

        # For each PETSc solve, build the PETSc objects required.
        petsc_objs = build_petsc_objects(sol.target)


    body = iet.body._rebuild(body=(tuple(setup) + iet.body.body))
    iet = iet._rebuild(body=body)



    return iet, {}


def drop_dummies(iet):

    # If a PETScDummyExpr is alongside non
    # PETScDummyExprs (e.g standard expressions) then just drop the PETScDummyExpr, otherwise drop
    # the entire iteration loop containing the PETScDummyExpr

    mapper = {}
    for tree in retrieve_iteration_tree(iet):
        root = filter_iterations(tree, key=lambda i: i.dim.is_Space)[0]

        dummy = FindNodes(PETScDumExpr).visit(root)
        if dummy:
            if any(not isinstance(i, PETScDumExpr) for i in FindNodes(Expression).visit(root)):
                mapper.update({dummy[0]: None})
            else:
                mapper.update({root: None})

    
    iet = Transformer(mapper, nested=True).visit(iet)

    return iet


def petsc_setup():

    header = c.Line('PetscFunctionBeginUser;')

    size = PetscMPIInt(name='size')

    # TODO: This will obv change when it is working with MPI.
    initialize = Call('PetscCall', [Call('PetscInitialize',
                                         arguments=['NULL', 'NULL',
                                                    'NULL', 'NULL'])])
    
    call_mpi = Call('PetscCallMPI', [Call('MPI_Comm_size',
                                          arguments=['PETSC_COMM_WORLD',
                                                     Byref(size)])])

    return [header, initialize, call_mpi]



def build_petsc_objects(target):
    # TODO: Eventually, the objects built will be based
    # on the number of different PETSc equations present etc.

    return {'A_matfree': Mat(name='A_matfree'+str(target.name)),
            'xvec': Vec(name='xvec'+str(target.name)),
            'local_xvec': Vec(name='local_xvec'+str(target.name), liveness='eager'),
            'yvec': Vec(name='yvec'+str(target.name)),
            'da': DM(name='da'+str(target.name), liveness='eager'),
            'x': Vec(name='x'+str(target.name)),
            'b': Vec(name='b'+str(target.name)),
            'ksp': KSP(name='ksp'+str(target.name)),
            'pc': PC(name='pc'+str(target.name)),
            'err': PetscErrorCode(name='err'+str(target.name)),
            'reason': PetscErrorCode(name='reason'+str(target.name)),
            'xvec_tmp': (PETScArray(name='xvec_tmp'+str(target.name), dtype=target.dtype,
                                    dimensions=target.dimensions,
                                    shape=target.shape,
                                    liveness='eager'))}


def build_struct(mapper):

    # Place all symbols required by all PETSc solves into the same struct. 
    usr_ctx = []

    # for iter, _ in mapper.items():
        # Build the struct
    tmp1 = FindSymbols('basics').visit(iter)
    tmp2 = FindSymbols('dimensions|indexedbases').visit(iter)
    usr_ctx.extend(symb for symb in tmp1 if symb not in tmp2)

    return PETScStruct('ctx', usr_ctx)


def build_matvec_body(action, objs, struct, expr_target):

    # for iter, (action,)  in mapper.items():
        # from IPython import embed; embed()

        # target = 
        # xvec_tmp =  PETScArray(name='xvec_tmp', dtype=target.dtype,
        #                             dimensions=target.dimensions,
        #                             shape=target.shape,
        #                             liveness='eager')

    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                        arguments=[objs['A_matfree'],
                                                    Byref(struct)])])

    mat_get_dm = Call('PetscCall', [Call('MatGetDM',
                                        arguments=[objs['A_matfree'],
                                                    Byref(objs['da'])])])

    dm_get_local_xvec = Call('PetscCall', [Call('DMGetLocalVector',
                                                arguments=[objs['da'],
                                                        Byref(objs['local_xvec'])])])

    dm_global_local_begin = Call('PetscCall', [Call('DMGlobalToLocalBegin',
                                                    arguments=[objs['da'],
                                                            objs['xvec'],
                                                            'INSERT_VALUES',
                                                            objs['local_xvec']])])

    dm_global_local_end = Call('PetscCall', [Call('DMGlobalToLocalEnd',
                                                arguments=[objs['da'],
                                                            objs['xvec'],
                                                            'INSERT_VALUES',
                                                            objs['local_xvec']])])

    dm_vec_get_array_read = Call('PetscCall',
                                [Call('DMDAVecGetArrayRead',
                                    arguments=[objs['da'],
                                                objs['local_xvec'],
                                                Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_get_array = Call('PetscCall',
                            [Call('DMDAVecGetArray',
                                arguments=[objs['da'],
                                            objs['yvec'],
                                            Byref(expr_target.write._C_symbol)])])

    dm_vec_restore_array_read = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArrayRead', arguments=[objs['da'],
                                                    objs['local_xvec'],
                                                    Byref(objs['xvec_tmp']._C_symbol)])])

    dm_vec_restore_array = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArray', arguments=[objs['da'],
                                                objs['yvec'],
                                                Byref(expr_target.write._C_symbol)])])

    dm_restore_local_vec = Call(
        'PetscCall',
        [Call('DMRestoreLocalVector', arguments=[objs['da'],
                                                Byref(objs['local_xvec'])])])

    func_return = Call('PetscFunctionReturn', arguments=[0])

    body = List(header=c.Line('PetscFunctionBegin;'),
                body=[Definition(struct),
                    get_context,
                    mat_get_dm,
                    dm_get_local_xvec,
                    dm_global_local_begin,
                    dm_global_local_end,
                    dm_vec_get_array_read,
                    dm_vec_get_array,
                    action,
                    # TODO: Track BCs through PETScSolve This line will come
                    # from the BCs.
                    c.Line('yvec_tmp[0][0]= xvec_tmp[0][0];'),
                    dm_vec_restore_array_read,
                    dm_vec_restore_array,
                    dm_restore_local_vec,
                    func_return])

    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)

    return body


def build_solve(matvec_body, pre_body, objs, struct, target):
    # TODO: Many of these args will be set based on user provided args in
    # PETScSolve

    # TODO: Create class type that generates this line
    func_begin_user = c.Line('PetscFunctionBeginUser;')

    call_mpi = Call('PetscCallMPI', [Call('MPI_Comm_size',
                                          arguments=['PETSC_COMM_WORLD',
                                                     Byref(objs['size'])])])

    # TODO: Create DM based on the dimensions of the target field i.e
    # this determines DMDACreate2d, 3d etc
    dm_create = Call('PetscCall', [Call('DMDACreate2d',
                                        arguments=['PETSC_COMM_SELF',
                                                   'DM_BOUNDARY_MIRROR',
                                                   'DM_BOUNDARY_MIRROR',
                                                   'DMDA_STENCIL_STAR',
                                                   target.shape[0],
                                                   target.shape[1],
                                                   'PETSC_DECIDE',
                                                   'PETSC_DECIDE',
                                                   1, 1,
                                                   'NULL', 'NULL',
                                                   Byref(objs['da'])])])

    dm_set_from_options = Call('PetscCall', [Call('DMSetFromOptions',
                                                  arguments=[objs['da']])])

    dm_setup = Call('PetscCall', [Call('DMSetUp', arguments=[objs['da']])])

    dm_set_mattype = Call('PetscCall', [Call('DMSetMatType',
                                             arguments=[objs['da'],
                                                        'MATSHELL'])])

    dm_create_mat = Call('PetscCall', [Call('DMCreateMatrix',
                                            arguments=[objs['da'],
                                                       Byref(objs['A_matfree'])])])

    matvec_callback = Callable('MyMatShellMult',
                               matvec_body,
                               retval=objs['err'],
                               parameters=(objs['A_matfree'],
                                           objs['xvec'],
                                           objs['yvec']))

    pre_callback = Callable('preconditioner_callback',
                            pre_body,
                            retval=objs['err'],
                            parameters=(objs['A_matfree'],
                                        objs['yvec']))

    matvec_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[objs['A_matfree'],
                                                          'MATOP_MULT',
                                                          Callback(matvec_callback.name,
                                                                   'void', 'void')])])

    jacobi_operation = Call('PetscCall', [Call('MatShellSetOperation',
                                               arguments=[objs['A_matfree'],
                                                          'MATOP_GET_DIAGONAL',
                                                          Callback(pre_callback.name,
                                                                   'void', 'void')])])

    set_context = Call('PetscCall', [Call('MatShellSetContext',
                                          arguments=[objs['A_matfree'],
                                                     struct])])

    dm_create_global_vec_x = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['x'])])])
    dm_create_global_vec_b = Call('PetscCall', [Call('DMCreateGlobalVector',
                                                     arguments=[objs['da'],
                                                                Byref(objs['b'])])])

    ksp_create = Call('PetscCall', [Call('KSPCreate',
                                         arguments=['PETSC_COMM_SELF',
                                                    Byref(objs['ksp'])])])

    ksp_set_operators = Call('PetscCall', [Call('KSPSetOperators',
                                                arguments=[objs['ksp'],
                                                           objs['A_matfree'],
                                                           objs['A_matfree']])])

    ksp_set_tol = Call('PetscCall', [Call('KSPSetTolerances',
                                          arguments=[objs['ksp'],
                                                     '1.e-7',
                                                     'PETSC_DEFAULT',
                                                     'PETSC_DEFAULT',
                                                     'PETSC_DEFAULT'])])

    ksp_set_type = Call('PetscCall', [Call('KSPSetType',
                                           arguments=[objs['ksp'],
                                                      'KSPGMRES'])])

    ksp_get_pc = Call('PetscCall', [Call('KSPGetPC',
                                         arguments=[objs['ksp'],
                                                    Byref(objs['pc'])])])

    pc_set_type = Call('PetscCall', [Call('PCSetType',
                                          arguments=[objs['pc'],
                                                     'PCJACOBI'])])

    pc_jacobi_set_type = Call('PetscCall', [Call('PCJacobiSetType',
                                                 arguments=[objs['pc'],
                                                            'PC_JACOBI_DIAGONAL'])])

    ksp_set_from_opts = Call('PetscCall', [Call('KSPSetFromOptions',
                                                arguments=[objs['ksp']])])

    body = List(body=[func_begin_user,
                      initialize,
                      call_mpi,
                      dm_create,
                      dm_set_from_options,
                      dm_setup,
                      dm_set_mattype,
                      dm_create_mat,
                      matvec_operation,
                      jacobi_operation,
                      set_context,
                      dm_create_global_vec_x,
                      dm_create_global_vec_b,
                      ksp_create,
                      ksp_set_operators,
                      ksp_set_tol,
                      ksp_set_type,
                      ksp_get_pc,
                      pc_set_type,
                      pc_jacobi_set_type,
                      ksp_set_from_opts])

    return matvec_callback, pre_callback, body


def build_rhs_setup(objs, b_tmp):

    dm_vec_get_array = Call('PetscCall', [Call('DMDAVecGetArray',
                                               arguments=[objs['da'],
                                                          objs['b'],
                                                          Byref(b_tmp)])])

    # body = List(body=[dm_vec_get_array])

    return dm_vec_get_array


def execute_solve(objs, b_tmp, sol_mapping, x_tmp):

    dm_vec_restore_array_b = Call('PetscCall', [Call('DMDAVecRestoreArray',
                                                     arguments=[objs['da'],
                                                                objs['b'],
                                                                Byref(b_tmp)])])

    ksp_solve = Call('PetscCall', [Call('KSPSolve',
                                        arguments=[objs['ksp'],
                                                   objs['b'],
                                                   objs['x']])])

    ksp_get_converged_reason = Call('PetscCall',
                                    [Call('KSPGetConvergedReason',
                                          arguments=[objs['ksp'],
                                                     Byref(objs['reason'])])])

    dm_vec_get_array_x = Call('PetscCall', [Call('DMDAVecGetArray',
                                                 arguments=[objs['da'],
                                                            objs['x'],
                                                            Byref(x_tmp)])])

    dm_vec_restore_array_x = Call('PetscCall', [Call('DMDAVecRestoreArray',
                                                     arguments=[objs['da'],
                                                                objs['x'],
                                                                Byref(x_tmp)])])

    # TODO: DESTROY OBJECTS

    tmp_line = c.Line('PetscPrintf(PETSC_COMM_WORLD, "Convergence reason: %s", \
                      KSPConvergedReasons[reason]);'),

    body = List(body=[dm_vec_restore_array_b,
                      ksp_solve,
                      ksp_get_converged_reason,
                      tmp_line,
                      dm_vec_get_array_x,
                      sol_mapping,
                      dm_vec_restore_array_x])

    return body


def build_pre_body(pre_iteration, objs, struct, expr_target):

    get_context = Call('PetscCall', [Call('MatShellGetContext',
                                          arguments=[objs['A_matfree'],
                                                     Byref(struct)])])

    mat_get_dm = Call('PetscCall', [Call('MatGetDM',
                                         arguments=[objs['A_matfree'],
                                                    Byref(objs['da'])])])

    dm_vec_get_array = Call('PetscCall',
                            [Call('DMDAVecGetArray',
                                  arguments=[objs['da'],
                                             objs['yvec'],
                                             Byref(expr_target.write._C_symbol)])])

    dm_vec_restore_array = Call(
        'PetscCall',
        [Call('DMDAVecRestoreArray', arguments=[objs['da'],
                                                objs['yvec'],
                                                Byref(expr_target.write._C_symbol)])])

    func_return = Call('PetscFunctionReturn', arguments=[0])

    body = List(header=c.Line('PetscFunctionBegin;'),
                body=[Definition(struct),
                      get_context,
                      mat_get_dm,
                      dm_vec_get_array,
                      pre_iteration,
                      # TODO: Track BCs through PETScSolve This line
                      # will come from the BCs.
                      c.Line('yvec_tmp[0][0]=1.;'),
                      dm_vec_restore_array,
                      func_return])

    # Replace all symbols in the body that appear in the struct
    # with a pointer to the struct.
    for i in struct.usr_ctx:
        body = Uxreplace({i: FieldFromPointer(i, struct)}).visit(body)
    return body
