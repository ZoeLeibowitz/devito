from devito.tools import CustomDtype
from devito.types import LocalObject, Eq
from devito.types.array import ArrayBasic
import numpy as np
from cached_property import cached_property
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
import sympy
from devito.tools import Reconstructable


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'liveness', 'coefficients'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @cached_property
    def _C_ctype(self):
        petsc_type = dtype_to_petsctype(self.dtype)
        modifier = '*' * len(self.dimensions)
        return CustomDtype(petsc_type, modifier=modifier)

    @property
    def _C_name(self):
        return self.name


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class MatVecEq(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):

    # TODO: This is a placeholder for the actual implementation. To start,
    # track different PETScEq's (MatVecAction, RHS) through the Operator.

    y_matvec = PETScArray(name='y_matvec_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')

    x_matvec = PETScArray(name='x_matvec_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')

    b_tmp = PETScArray(name='b_tmp_'+str(target.name), dtype=target.dtype,
                       dimensions=target.dimensions,
                       shape=target.shape, liveness='eager')

    # # TODO: Extend to rearrange equation for implicit time stepping.
    matvecaction = MatVecEq(y_matvec, LinearSolveExpr(eq.lhs.subs(target, x_matvec),
                            target=target, solver_parameters=solver_parameters),
                            subdomain=eq.subdomain)

    rhs = RHSEq(b_tmp, LinearSolveExpr(eq.rhs, target=target,
                solver_parameters=solver_parameters), subdomain=eq.subdomain)

    return [matvecaction] + [rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters',)

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi'
    }

    def __new__(cls, expr, target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = sympy.Function.__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def _hashable_content(self):
        return super()._hashable_content() + (self.expr, self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    func = Reconstructable._rebuild
