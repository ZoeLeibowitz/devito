from devito.tools import CustomDtype
from devito.types import LocalObject, Eq
from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
import numpy as np
from cached_property import cached_property
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
import sympy
from devito.tools import Reconstructable
from devito.symbolics import FieldFromComposite

class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - C struct containing information
    about the local grid.
    """
    dtype = CustomDtype('DMDALocalInfo')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'liveness', 'coefficients'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @cached_property
    def _C_ctype(self):
        return CustomDtype(self.petsc_type, modifier='*')

    @property
    def petsc_type(self):
        return dtype_to_petsctype(self._dtype)

    @property
    def dtype(self):
        return CustomDtype(self.petsc_type)

    @property
    def symbolic_shape(self):
        info = DMDALocalInfo(name='info')
        locals = ['gxm', 'gym', 'gzm']
        field_from_composites = [
            FieldFromComposite(lgp, info) for lgp in locals[:len(self.dimensions)]]
        ret = tuple(i for i in field_from_composites)
        return DimensionTuple(*ret, getters=self.dimensions)


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class LinearSolveEq(Eq):
    """
    Represents a general equation required by PETScSolve.
    """

    __rkwargs__ = (Eq.__rkwargs__ + ('target', 'solver_parameters',))

    # TODO: Add more solver parameters
    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi',
        'ksp_rtol': 'PETSC_DEFAULT',
        'ksp_atol': 'PETSC_DEFAULT',
        'ksp_divtol': 'PETSC_DEFAULT',
        'ksp_max_it': 'PETSC_DEFAULT'
    }

    def __new__(cls, lhs, rhs=0, subdomain=None, coefficients=None, implicit_dims=None,
                target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = Eq.__new__(cls, lhs, rhs, subdomain=subdomain, coefficients=coefficients,
                         implicit_dims=implicit_dims, **kwargs)
        obj._target = target
        obj._solver_parameters = solver_parameters

        return obj

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters
    

class MatVecEq(LinearSolveEq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    pass


class MockEq(Eq):
    """
    Represents a mock/placeholder equation to ensure distinct iteration loops.

    For example, the mat-vec action iteration loop is to be isolated from the
    expression loop used to build the RHS of the linear system. This separation
    facilitates the utilisation of the mat-vec iteration loop in callback functions
    created at the IET level.
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):

    # TODO: This is a placeholder for the actual implementation. To start,
    # track a single PETScEq i.e an 'Action' through the Operator.

    y_matvec = PETScArray(name='y_matvec_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')
    
    x_matvec = PETScArray(name='x_matvec_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')
    
    b_tmp = PETScArray(name='b_tmp_'+str(target.name), dtype=target.dtype,
                       dimensions=target.dimensions,
                       shape=target.shape, liveness='eager')
    
    # TODO: Extend to rearrange equation for implicit time stepping. 
    action_tmp = Action(y_matvec, eq.lhs, subdomain=eq.subdomain, target=target,
                        solver_parameters=solver_parameters)
    
    rhs = RHS(b_tmp, eq.rhs, subdomain=eq.subdomain, target=target,
              solver_parameters=solver_parameters)

    # Only need symbolic representation of equation in mat-vec action callback.
    action = action_tmp.subs(target, x_matvec)


    
    return [action] + [rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters')

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi'
    }

    def __new__(cls, expr, target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = super().__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    func = Reconstructable._rebuild


class Mock(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)

    def __new__(cls, expr, **kwargs):

        obj = super().__new__(cls, expr)
        obj._expr = expr
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    @property
    def expr(self):
        return self._expr

    func = Reconstructable._rebuild
