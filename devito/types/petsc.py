import sympy
import numpy as np

from devito.tools import CustomDtype
from devito.types import LocalObject, Eq
from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from cached_property import cached_property
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import Reconstructable
from devito.symbolics import FieldFromComposite
from devito.types.basic import IndexedBase


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - C struct containing information
    about the local grid.
    """
    dtype = CustomDtype('DMDALocalInfo')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'liveness', 'coefficients'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @cached_property
    def _C_ctype(self):
        return CustomDtype(self.petsc_type, modifier='*')

    @property
    def petsc_type(self):
        return dtype_to_petsctype(self._dtype)

    @property
    def dtype(self):
        return CustomDtype(self.petsc_type)

    @property
    def symbolic_shape(self):
        info = DMDALocalInfo(name='info')
        # To access the local grid info via the DM in
        # PETSc you use DMDAGetLocalInfo(da, &info)
        # and then access the local no.of grid points via info.gmx, info.gmy, info.gmz
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, info) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    @cached_property
    def indexed(self):
        return PETScIndexedData(self.name, shape=self._shape, function=self.function)


class PETScIndexedData(IndexedBase):
    pass


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class MatVecEq(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):

    # TODO: Add check for time dimensions and utilise implicit dimensions.

    y_matvec, x_matvec, b_tmp = [
        PETScArray(name=f'{prefix}_{target.name}',
                   dtype=target.dtype,
                   dimensions=target.dimensions,
                   shape=target.shape, liveness='eager',
                   halo=target.halo)
        for prefix in ['y_matvec', 'x_matvec', 'b_tmp']]

    # # TODO: Extend to rearrange equation for implicit time stepping.
    matvecaction = MatVecEq(y_matvec, LinearSolveExpr(eq.lhs.subs(target, x_matvec),
                            target=target, solver_parameters=solver_parameters),
                            subdomain=eq.subdomain)

    rhs = RHSEq(b_tmp, LinearSolveExpr(eq.rhs, target=target,
                solver_parameters=solver_parameters), subdomain=eq.subdomain)

    # Create mock equations to ensure distinct iteration loops for each component
    # of the linear solve.
    indices = tuple(d + 1 for d in target.dimensions)
    s0 = Symbol(name='s0')
    s1 = Symbol(name='s1')

    # Wrapped rhs in LinearSolveExpr for simplicity in iet_build pass.
    mock_action = Eq(s0, Mock(y_matvec.indexify(indices=indices)))
    mock_rhs = Eq(s1, Mock(b_tmp.indexify(indices=indices)))

    return [matvecaction, mock_action] + [rhs, mock_rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters')

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi'
    }

    def __new__(cls, expr, target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = super().__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    func = Reconstructable._rebuild


class Mock(sympy.Function, Reconstructable):

    """
    Represents a mock/placeholder RHS to ensure distinct iteration loops.

    For example, the mat-vec action iteration loop is to be isolated from the
    expression loop used to build the RHS of the linear system. This separation
    facilitates the utilisation of the mat-vec iteration loop in callback functions
    created at the IET level.
    """

    __rargs__ = ('expr',)

    def __new__(cls, expr, **kwargs):

        obj = super().__new__(cls, expr)
        obj._expr = expr
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    @property
    def expr(self):
        return self._expr

    func = Reconstructable._rebuild
