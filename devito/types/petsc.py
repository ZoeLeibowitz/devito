import sympy
import numpy as np
from devito.tools import CustomDtype
from devito.types import LocalObject, Eq
from cached_property import cached_property
from devito.finite_differences import Differentiable
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import Reconstructable, ctypes_to_cstr, as_tuple
from devito.types.basic import AbstractFunction, Scalar
from devito.types.utils import DimensionTuple
from devito.symbolics import FieldFromComposite



class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - 
    """
    dtype = CustomDtype('DMDALocalInfo')


class LocalFunction(AbstractFunction, Differentiable):

    is_LocalFunction = True

    __rkwargs__ = AbstractFunction.__rkwargs__ + ('is_const', 'liveness', 'coefficients')

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    def __init_finalize__(self, *args, **kwargs):

        self._liveness = kwargs.setdefault('liveness', 'lazy')
        super().__init_finalize__(*args, **kwargs)
        self._is_const = kwargs.get('is_const', False)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

    @classmethod
    def __indices_setup__(cls, *args, **kwargs):
        dimensions = kwargs['dimensions']

        if args:
            indices = args
        else:
            indices = dimensions

        return as_tuple(dimensions), as_tuple(indices)
    
    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def _C_name(self):
        if self._mem_stack or self._mem_constant:
            # No reason to distinguish between two different names, that is
            # the _C_name and the name -- just `self.name` is enough
            return self.name
        else:
            return super()._C_name

    @cached_property
    def shape(self):
        ret = [i.symbolic_size for i in self.dimensions]
        return DimensionTuple(*ret, getters=self.dimensions)
    
    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape_allocated(self):
        return self.symbolic_shape

    @property
    def is_const(self):
        return self._is_const

    @property
    def liveness(self):
        return self._liveness

    @property
    def _mem_internal_eager(self):
        return self._liveness == 'eager'

    @property
    def _mem_internal_lazy(self):
        return self._liveness == 'lazy'


class PETScFunction(LocalFunction):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    @property
    def _C_ctype(self):
        modifier = '*'
        return CustomDtype(self.petsc_type, modifier=modifier)
    
    @property
    def petsc_type(self):
        return dtype_to_petsctype(self._dtype)

    @property
    def dtype(self):
        return CustomDtype(self.petsc_type)
    
    @property
    def symbolic_shape(self):
        info = DMDALocalInfo(name='info')
        local_grid_points = ['gxm', 'gym', 'gzm']
        field_from_composites = [FieldFromComposite(lgp, info) for lgp in local_grid_points]
        domain = [field_from_composites[i] for i, _ in enumerate(self.dimensions)]
        ret = tuple(i for i in domain)
        return DimensionTuple(*ret, getters=self.dimensions)


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class MatVecEq(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):

    # TODO: This is a placeholder for the actual implementation. To start,
    # track different PETScEq's (MatVecAction, RHS) through the Operator.

    y_matvec, x_matvec, b_tmp = [
        PETScFunction(name=f'{prefix}_{target.name}',
                   dtype=target.dtype,
                   dimensions=target.dimensions,
                   shape=target.shape, liveness='eager')
        for prefix in ['y_matvec', 'x_matvec', 'b_tmp']]

    # # TODO: Extend to rearrange equation for implicit time stepping.
    matvecaction = MatVecEq(y_matvec, LinearSolveExpr(eq.lhs.subs(target, x_matvec),
                            target=target, solver_parameters=solver_parameters),
                            subdomain=eq.subdomain)

    rhs = RHSEq(b_tmp, LinearSolveExpr(eq.rhs, target=target,
                solver_parameters=solver_parameters), subdomain=eq.subdomain)

    return [matvecaction] + [rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters')

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi'
    }

    def __new__(cls, expr, target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = super().__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    func = Reconstructable._rebuild
