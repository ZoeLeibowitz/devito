from devito.tools import CustomDtype, dtype_to_ctype
from devito.types import LocalObject, CompositeObject
from devito.types.basic import Symbol
from devito.types.array import ArrayBasic
import numpy as np
from cached_property import cached_property
from devito.types.equation import Eq

__all__ = ['PETScSolve']


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class PetscErrorCode(LocalObject):
    """
    PETSc datatype used to return PETSc error codes.
    https://petsc.org/release/manualpages/Sys/PetscErrorCode/
    """
    dtype = CustomDtype('PetscErrorCode')


class PETScArray(ArrayBasic):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    """

    _data_alignment = False

    __rkwargs__ = (ArrayBasic.__rkwargs__ +
                   ('liveness',))

    def __init_finalize__(self, *args, **kwargs):
        super().__init_finalize__(*args, **kwargs)

        self._liveness = kwargs.get('liveness', 'lazy')
        assert self._liveness in ['eager', 'lazy']

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @cached_property
    def _C_ctype(self):
        petsc_type = dtype_to_petsctype(self.dtype)
        modifier = '*' * len(self.dimensions)
        return CustomDtype(petsc_type, modifier=modifier)

    @property
    def _C_name(self):
        return self.name

    @property
    def liveness(self):
        return self._liveness

    @property
    def _mem_internal_eager(self):
        return self._liveness == 'eager'

    @property
    def _mem_internal_lazy(self):
        return self._liveness == 'lazy'


def dtype_to_petsctype(dtype):
    """
    Map numpy types to PETSc datatypes.

    TODO: If a user creates an object e.g a Function with
    double precision but their PETSc is configured to single
    precision then throw a warning etc.
    """
    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class Action(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """

    __rkwargs__ = (Eq.__rkwargs__ + ('target',))

    def __new__(cls, lhs, rhs=0, subdomain=None, coefficients=None, implicit_dims=None,
                target=None, **kwargs):
        obj = Eq.__new__(cls, lhs, rhs, subdomain=subdomain, coefficients=coefficients,
                         implicit_dims=implicit_dims, **kwargs)
        obj._target = target

        return obj
    
    @property
    def target(self):
        return self._target



class RHS(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    __rkwargs__ = (Eq.__rkwargs__ + ('target',))

    def __new__(cls, lhs, rhs=0, subdomain=None, coefficients=None, implicit_dims=None,
                target=None, **kwargs):
        obj = Eq.__new__(cls, lhs, rhs, subdomain=subdomain, coefficients=coefficients,
                         implicit_dims=implicit_dims, **kwargs)
        obj._target = target

        return obj
    
    @property
    def target(self):
        return self._target


class PreStencil(Eq):
    """
    Eq needed for the preconditioner callback.
    """
    __rkwargs__ = (Eq.__rkwargs__ + ('target',))

    def __new__(cls, lhs, rhs=0, subdomain=None, coefficients=None, implicit_dims=None,
                target=None, **kwargs):
        obj = Eq.__new__(cls, lhs, rhs, subdomain=subdomain, coefficients=coefficients,
                         implicit_dims=implicit_dims, **kwargs)
        obj._target = target

        return obj
    
    @property
    def target(self):
        return self._target
    

class Solution(Eq):
    """
    Eq needed to pass solution Vec x back to Devito.
    """
    __rkwargs__ = (Eq.__rkwargs__ + ('target',))

    def __new__(cls, lhs, rhs=0, subdomain=None, coefficients=None, implicit_dims=None,
                target=None, **kwargs):
        obj = Eq.__new__(cls, lhs, rhs, subdomain=subdomain, coefficients=coefficients,
                         implicit_dims=implicit_dims, **kwargs)
        obj._target = target

        return obj
    
    @property
    def target(self):
        return self._target


class PETScDummy(Eq):
    """
    """
    pass


def PETScSolve(eq, target, bcs=None, **kwargs):

    y_matvec = PETScArray(name='y_matvec_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')
    
    y_pre = PETScArray(name='y_pre_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')

    b = PETScArray(name='b_'+str(target.name), dtype=target.dtype,
                       dimensions=target.dimensions,
                       shape=target.shape, liveness='eager')
    
    x = PETScArray(name='x_'+str(target.name), dtype=target.dtype,
                          dimensions=target.dimensions,
                          shape=target.shape, liveness='eager')

    # TODO: Extend to different preconditioners but for now just considering
    # JACOBI diagonal.
    from devito import Derivative
    terms = eq.lhs.as_ordered_terms()
    centre_stencil = sum(
        [d._eval_deriv_centre for d in terms if isinstance(d, Derivative)])

    # For now, assume the application of the linear operator on
    # a vector is eqn.lhs

    from devito.types import Symbol
    s0 = Symbol(name='s0')
    s1 = Symbol(name='s1')
    s2 = Symbol(name='s2')
    s3 = Symbol(name='s3')
    s4 = Symbol(name='s4')

    # from devito.types import CriticalRegion, WeakFence

    # The equations that are supplied to callback functions will
    # always have to be in separated loops. 

    # bc_for_matvec = []
    # for bc in bcs:
    #     bc_for_matvec.append(Action(y_matvec.indexify(indices=bc.lhs.indices), bc.rhs))


    # Create Dummy equations.
    indices = tuple(d + 1 for d in target.dimensions)
    eqn_dims = eq.lhs.dimensions + eq.rhs.dimensions

    # Using implicit dimensions to merge eveything into the time loop if necessary.

    if any(d.is_Time for d in eqn_dims):

        preconditioner = PreStencil(y_pre, centre_stencil, implicit_dims=(target.grid.time_dim,), target=target)
        action = Action(y_matvec, eq.lhs, implicit_dims=(target.grid.time_dim,), target=target)
        rhs = RHS(b, eq.rhs, implicit_dims=(target.grid.time_dim,), target=target)
        solution = Solution(target, x, implicit_dims=(target.grid.time_dim,), target=target)

        dummy_pre = PETScDummy(s0, y_pre.indexify(indices=indices), implicit_dims=(target.grid.time_dim,))
        dummy_action = PETScDummy(s1, y_matvec.indexify(indices=indices), implicit_dims=(target.grid.time_dim,))
        dummy_rhs = PETScDummy(s2, b.indexify(indices=indices), implicit_dims=(target.grid.time_dim,))
        dummy_sol = PETScDummy(s3, target.indexify(indices=indices), implicit_dims=(target.grid.time_dim,))

    else:
    
        preconditioner = PreStencil(y_pre, centre_stencil, target=target)
        action = Action(y_matvec, eq.lhs, target=target)
        rhs = RHS(b, eq.rhs, target=target)
        solution = Solution(target, x, target=target)

        dummy_pre = PETScDummy(s0, y_pre.indexify(indices=indices))
        dummy_action = PETScDummy(s1, y_matvec.indexify(indices=indices))
        dummy_rhs = PETScDummy(s2, b.indexify(indices=indices))
        dummy_sol = PETScDummy(s3, target.indexify(indices=indices))


    return [preconditioner, dummy_pre] + [action, dummy_action] + [solution, dummy_sol] + [rhs, dummy_rhs]


class PETScStruct(CompositeObject):

    __rargs__ = ('name', 'usr_ctx',)

    def __init__(self, name, usr_ctx):
        pfields = [(i._C_name,
                    dtype_to_ctype(i.dtype)) for i in usr_ctx if isinstance(i, Symbol)]
        self._usr_ctx = usr_ctx
        super().__init__(name, 'MatContext', pfields)

    @property
    def usr_ctx(self):
        return self._usr_ctx

    def _arg_values(self, **kwargs):
        values = super()._arg_values(**kwargs)
        for i in self.fields:
            setattr(values[self.name]._obj, i, kwargs['args'][i])
        return values
