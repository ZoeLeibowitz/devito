from functools import cached_property
import numpy as np
from ctypes import POINTER

from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import dtype_to_ctype, as_tuple
from devito.symbolics import FieldFromComposite
from devito.types import Symbol
from devito.data import FULL

from .object import DM, DMDALocalInfo



class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.

    PETScArray objects represent vector objects within PETSc.
    They correspond to the spatial domain of a Function-like object passed
    into PETScSolve from a user.

    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('target', 'liveness', 'coefficients'))

    def __init_finalize__(self, *args, **kwargs):

        self._target = kwargs.get('target')
        self._ndim = kwargs['ndim'] = len(self._target.space_dimensions)
        self._dimensions = kwargs['dimensions'] = self._target.space_dimensions

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

    @property
    def ndim(self):
        return self._ndim

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs['target'].dtype

    @classmethod
    def __indices_setup__(cls, *args, **kwargs):
        dimensions = kwargs['target'].space_dimensions
        if args:
            indices = args
        else:
            indices = dimensions
        return as_tuple(dimensions), as_tuple(indices)

    @property
    def dimensions(self):
        return self._dimensions

    @property
    def target(self):
        return self._target

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self.target.grid.shape

    @property
    def space_order(self):
        return self.target.space_order

    @cached_property
    def _shape_with_inhalo(self):
        return self.target.shape_with_inhalo

    @cached_property
    def shape_allocated(self):
        return self.target.shape_allocated

    @cached_property
    def _C_ctype(self):
        # NOTE: Reverting to using float/double instead of PetscScalar for
        # simplicity when opt='advanced'. Otherwise, Temp objects must also
        # be converted to PetscScalar. Additional tests are needed to
        # ensure this approach is fine. Previously, issues arose from
        # mismatches between precision of Function objects in Devito and the
        # precision of the PETSc configuration.
        # TODO: Use cat $PETSC_DIR/$PETSC_ARCH/lib/petsc/conf/petscvariables
        # | grep -E "PETSC_(SCALAR|PRECISION)" to determine the precision of
        # the user's PETSc configuration.
        return POINTER(dtype_to_ctype(self.dtype))

    @property
    def halo(self):
        return [self.target.halo[d] for d in self.target.space_dimensions]

    def __halo_setup__(self, **kwargs):
        target = kwargs['target']
        halo = [target.halo[d] for d in target.space_dimensions]
        # halo = tuple(kwargs.get('halo', ((0, 0),)*self.ndim))
        return DimensionTuple(*halo, getters=target.space_dimensions)

    # @property
    # def symbolic_shape(self):
    #     # from IPython import embed; embed()
    #     if self.dmda:
    #         field_from_composites = [
    #             FieldFromComposite('g%sm' % d.name, self.dmda.info) for d in self.dimensions]
    #         # Reverse it since DMDA is setup backwards to Devito dimensions.
    #         return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)
    #     else:
    #         return DimensionTuple(*self.dimensions)

    # @property
    # def symbolic_shape(self):
    #     # info = DMDALocalInfo(name='info', liveness='eager')

    #     field_from_composites = [
    #             FieldFromComposite('g%sm' % d.name, self.dmda_info) for d in self.dimensions]
        
    #         # Reverse it since DMDA is setup backwards to Devito dimensions.
    #     return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    # @cached_property
    # def dmda(self):
    #     name = 'da_so_%s' % self.space_order
    #     return DM(name=name, liveness='eager', stencil_width=self.space_order)

    # @cached_property
    # def dmda(self):
    #     return self._dmda

    @property
    def symbolic_shape(self):
        # TODO: double check if this should be reversed for dmda
        return tuple(self.target._C_get_field(FULL, d).size for d in self.dimensions)

    # @property
    # def dmda_info(self):
    #     return DMDALocalInfo(name='info', liveness='eager')