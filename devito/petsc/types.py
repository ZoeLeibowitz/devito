import sympy
from functools import cached_property
import numpy as np

from devito.tools import CustomDtype
from devito.types import LocalObject, Eq, CompositeObject
from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction, Symbol
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import Reconstructable, dtype_to_ctype
from devito.symbolics import FieldFromComposite
from devito.types.basic import IndexedBase


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')

    def __init__(self, *args, stencil_width=None, **kwargs):
        super().__init__(*args, **kwargs)
        self._stencil_width = stencil_width

    @property
    def stencil_width(self):
        return self._stencil_width


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class SNES(LocalObject):
    """
    PETSc SNES : Non-Linear Systems Solvers.
    """
    dtype = CustomDtype('SNES')


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - C struct containing information
    about the local grid.
    """
    dtype = CustomDtype('DMDALocalInfo')


class PetscErrorCode(LocalObject):
    """
    PETSc datatype used to return PETSc error codes.
    https://petsc.org/release/manualpages/Sys/PetscErrorCode/
    """
    dtype = CustomDtype('PetscErrorCode')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'shape', 'liveness', 'coefficients'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))
        self._shape = kwargs.get('shape')

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self._shape

    @cached_property
    def _shape_with_inhalo(self):
        """
        Shape of the domain+inhalo region. The inhalo region comprises the
        outhalo as well as any additional "ghost" layers for MPI halo
        exchanges. Data in the inhalo region are exchanged when running
        Operators to maintain consistent values as in sequential runs.

        Notes
        -----
        Typically, this property won't be used in user code, but it may come
        in handy for testing or debugging
        """
        return tuple(j + i + k for i, (j, k) in zip(self.shape, self._halo))

    @cached_property
    def shape_allocated(self):
        """
        Shape of the allocated data of the Function type object from which
        this PETScArray was derived. It includes the domain and inhalo regions,
        as well as any additional padding surrounding the halo.

        Notes
        -----
        In an MPI context, this is the *local* with_halo region shape.
        """
        return DimensionTuple(*[j + i + k for i, (j, k) in zip(self._shape_with_inhalo,
                                                               self._padding)],
                              getters=self.dimensions)

    @cached_property
    def _C_ctype(self):
        return CustomDtype(self.petsc_type, modifier='*')

    @property
    def petsc_type(self):
        return dtype_to_petsctype(self._dtype)

    @property
    def dtype(self):
        return CustomDtype(self.petsc_type)

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.dmda_info) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    @cached_property
    def dmda_info(self):
        # To access the local grid info via the DM in
        # PETSc you use DMDAGetLocalInfo(da, &info)
        # and then access the local no.of grid points via info.gmx, info.gmy, info.gmz
        return DMDALocalInfo(name='info', liveness='eager')

    @cached_property
    def indexed(self):
        return PETScIndexedData(self.name, shape=self._shape, function=self.function)


class PETScIndexedData(IndexedBase):
    pass


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class MatVecEq(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers.
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression of building the
    rhs of a linear system.
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):
    # TODO: Add check for time dimensions and utilise implicit dimensions.

    is_time_dep = any(dim.is_Time for dim in target.dimensions)
    # TODO: Current assumption is rhs is part of pde that remains
    # constant at each timestep. Need to insert function to extract this from eq.
    y_matvec, x_matvec, b_tmp = [
        PETScArray(name=f'{prefix}_{target.name}',
                   dtype=target.dtype,
                   dimensions=target.space_dimensions,
                   shape=target.grid.shape,
                   liveness='eager',
                   halo=target.halo[1:] if is_time_dep else target.halo)
        for prefix in ['y_matvec', 'x_matvec', 'b_tmp']]

    # TODO: Extend to rearrange equation for implicit time stepping.
    matvecaction = MatVecEq(y_matvec, LinearSolveExpr(eq.lhs.subs(target, x_matvec),
                            target=target, solver_parameters=solver_parameters),
                            subdomain=eq.subdomain)

    # Part of pde that remains constant at each timestep
    rhs = RHSEq(b_tmp, LinearSolveExpr(eq.rhs, target=target,
                solver_parameters=solver_parameters), subdomain=eq.subdomain)

    if not bcs:
        return [matvecaction, rhs]

    else:
        bcs_for_matvec = []
        for bc in bcs:
            # TODO: Insert code to distiguish between essential and natural
            # boundary conditions since these are treated differently within
            # the solver
            # NOTE: May eventually remove the essential bcs from the solve
            # (and move to rhs) but for now, they are included since this
            # is not trivial to implement when using DMDA
            # NOTE: Below is temporary -> Just using this as a palceholder for
            # the actual BC implementation for the matvec callback
            bcs_for_matvec.append(MatVecEq(
                y_matvec, LinearSolveExpr(bc.lhs.subs(target, x_matvec),
                                          target=target,
                                          solver_parameters=solver_parameters),
                subdomain=bc.subdomain))

        return [matvecaction] + bcs_for_matvec + [rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters')

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi',
        'ksp_rtol': 1e-7,  # Relative tolerance
        'ksp_atol': 1e-50,  # Absolute tolerance
        'ksp_divtol': 1e4,  # Divergence tolerance
        'ksp_max_it': 10000  # Maximum iterations
    }

    def __new__(cls, expr, target=None, solver_parameters=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = super().__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    func = Reconstructable._rebuild


class PETScStruct(CompositeObject):

    __rargs__ = ('name', 'usr_ctx')

    def __init__(self, name, usr_ctx):
        pfields = [(i._C_name, dtype_to_ctype(i.dtype))
                   for i in usr_ctx if isinstance(i, Symbol)]
        self._usr_ctx = usr_ctx
        super().__init__(name, 'MatContext', pfields)

    @property
    def usr_ctx(self):
        return self._usr_ctx

    def _arg_values(self, **kwargs):
        values = super()._arg_values(**kwargs)
        for i in self.fields:
            setattr(values[self.name]._obj, i, kwargs['args'][i])
        return values
