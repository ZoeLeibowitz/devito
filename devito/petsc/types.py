import sympy

<<<<<<< HEAD
from devito.tools import Reconstructable, sympy_mutex
=======
from devito.tools import CustomDtype
from devito.types import LocalObject, Eq, CompositeObject
from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction, AbstractSymbol
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import dtype_to_ctype, Reconstructable, sympy_mutex
from devito.symbolics import FieldFromComposite, Byref


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')

    def __init__(self, *args, stencil_width=None, **kwargs):
        super().__init__(*args, **kwargs)
        self._stencil_width = stencil_width

    @property
    def stencil_width(self):
        return self._stencil_width

    @property
    def info(self):
        return DMDALocalInfo(name='%s_info' % self.name, liveness='eager')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        return petsc_call('DMDestroy', [Byref(self.function)])


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        return petsc_call('MatDestroy', [Byref(self.function)])


class LocalVec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')


class GlobalVec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        return petsc_call('VecDestroy', [Byref(self.function)])


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')


class SNES(LocalObject):
    """
    PETSc SNES : Non-Linear Systems Solvers.
    """
    dtype = CustomDtype('SNES')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        return petsc_call('SNESDestroy', [Byref(self.function)])


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - C struct containing information
    about the local grid.
    """
    dtype = CustomDtype('DMDALocalInfo')


class PetscErrorCode(LocalObject):
    """
    PETSc datatype used to return PETSc error codes.
    https://petsc.org/release/manualpages/Sys/PetscErrorCode/
    """
    dtype = CustomDtype('PetscErrorCode')


class DummyArg(LocalObject):
    dtype = CustomDtype('void', modifier='*')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'shape', 'liveness', 'coefficients',
                    'space_order'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))
        self._shape = kwargs.get('shape')
        self._space_order = kwargs.get('space_order', 1)

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self._shape

    @property
    def space_order(self):
        return self._space_order

    @cached_property
    def _shape_with_inhalo(self):
        """
        Shape of the domain+inhalo region. The inhalo region comprises the
        outhalo as well as any additional "ghost" layers for MPI halo
        exchanges. Data in the inhalo region are exchanged when running
        Operators to maintain consistent values as in sequential runs.

        Notes
        -----
        Typically, this property won't be used in user code, but it may come
        in handy for testing or debugging
        """
        return tuple(j + i + k for i, (j, k) in zip(self.shape, self._halo))

    @cached_property
    def shape_allocated(self):
        """
        Shape of the allocated data of the Function type object from which
        this PETScArray was derived. It includes the domain and inhalo regions,
        as well as any additional padding surrounding the halo.

        Notes
        -----
        In an MPI context, this is the *local* with_halo region shape.
        """
        return DimensionTuple(*[j + i + k for i, (j, k) in zip(self._shape_with_inhalo,
                                                               self._padding)],
                              getters=self.dimensions)

    @cached_property
    def _C_ctype(self):
        # NOTE: Reverting to using float/double instead of PetscScalar for
        # simplicity when opt='advanced'. Otherwise, Temp objects must also
        # be converted to PetscScalar. Additional tests are needed to
        # ensure this approach is fine. Previously, issues arose from
        # mismatches between precision of Function objects in Devito and the
        # precision of the PETSc configuration.
        # TODO: Use cat $PETSC_DIR/$PETSC_ARCH/lib/petsc/conf/petscvariables
        # | grep -E "PETSC_(SCALAR|PRECISION)" to determine the precision of
        # the user's PETSc configuration.
        return POINTER(dtype_to_ctype(self.dtype))

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.dmda.info) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    @property
    def dmda(self):
        name = 'da_so_%s' % self.space_order
        return DM(name=name, liveness='eager', stencil_width=self.space_order)


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


class InjectSolveEq(Eq):
    pass
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)


class LinearSolveExpr(sympy.Function, Reconstructable):

    __rargs__ = ('expr',)
<<<<<<< HEAD
<<<<<<< HEAD
    __rkwargs__ = ('target', 'solver_parameters', 'matvecs',
                   'formfuncs', 'formrhs', 'arrays')
=======
    __rkwargs__ = ('target', 'solver_parameters', 'matvecs', 'formfuncs', 'formrhs')
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)
=======
    __rkwargs__ = ('target', 'solver_parameters', 'matvecs',
                   'formfuncs', 'formrhs', 'arrays')
>>>>>>> b50c18397 (compiler: Clean up access to petsc arrays in each callback)

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi',
        'ksp_rtol': 1e-7,  # Relative tolerance
        'ksp_atol': 1e-50,  # Absolute tolerance
        'ksp_divtol': 1e4,  # Divergence tolerance
        'ksp_max_it': 10000  # Maximum iterations
    }

    def __new__(cls, expr, target=None, solver_parameters=None,
<<<<<<< HEAD
<<<<<<< HEAD
                matvecs=None, formfuncs=None, formrhs=None, arrays=None, **kwargs):
=======
                matvecs=None, formfuncs=None, formrhs=None, **kwargs):
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)
=======
                matvecs=None, formfuncs=None, formrhs=None, arrays=None, **kwargs):
>>>>>>> b50c18397 (compiler: Clean up access to petsc arrays in each callback)

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        with sympy_mutex:
            obj = sympy.Basic.__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        obj._matvecs = matvecs
        obj._formfuncs = formfuncs
        obj._formrhs = formrhs
<<<<<<< HEAD
<<<<<<< HEAD
        obj._arrays = arrays
=======
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)
=======
        obj._arrays = arrays
>>>>>>> b50c18397 (compiler: Clean up access to petsc arrays in each callback)
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.expr)

    def __eq__(self, other):
        return (isinstance(other, LinearSolveExpr) and
                self.expr == other.expr and
                self.target == other.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters

    @property
    def matvecs(self):
        return self._matvecs

    @property
    def formfuncs(self):
        return self._formfuncs

    @property
    def formrhs(self):
        return self._formrhs

<<<<<<< HEAD
<<<<<<< HEAD
    @property
    def formrhs(self):
        return self._formrhs
=======
=======
    @property
    def arrays(self):
        return self._arrays

>>>>>>> b50c18397 (compiler: Clean up access to petsc arrays in each callback)
    func = Reconstructable._rebuild


class PETScStruct(CompositeObject):

    __rargs__ = ('name', 'usr_ctx')
    __rkwargs__ = ('liveness',)

    # is_Input = True

    def __init__(self, name, usr_ctx, liveness='lazy'):
        pfields = [(i._C_name, dtype_to_ctype(i.dtype))
                   for i in usr_ctx if isinstance(i, AbstractSymbol)]
        self._usr_ctx = usr_ctx
        super().__init__(name, 'MatContext', pfields)
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)

        assert liveness in ['eager', 'lazy']
        self._liveness = liveness

    @property
    def arrays(self):
        return self._arrays

<<<<<<< HEAD
    func = Reconstructable._rebuild
=======
    def _arg_values(self, **kwargs):
        # TODO: Handle passing `struct dataobj *restrict g1_vec` and similar
        # elements within in the struct. It seemed necessary to convert the Numpy array
        # into a pointer to ctypes.Struct within MatContext
        # (i.e override _arg_finalize for PETScStruct here?), but this approach seemed
        # to result in a NIL pointer in the generated code ... any suggestions?
        # Alternative: Allow these pointers to appear in the main kernel arguments
        # as usual and use ctx->g1_vec = g1_vec; to assign them to the struct?
        values = super()._arg_values(**kwargs)
        for i in self.usr_ctx:
            setattr(values[self.name]._obj, i.name, kwargs['args'][i.name])
        return values

    @property
    def liveness(self):
        return self._liveness

    @property
    def _mem_internal_eager(self):
        return self._liveness == 'eager'

    @property
    def _mem_internal_lazy(self):
        return self._liveness == 'lazy'
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> 29ada0831 (compiler: form rhs in callback function and remove manual petsc casts)
=======
    
=======

>>>>>>> 9d611239f (compiler: Fix derive_callback_inputs)
    @property
    def fields(self):
        return self._usr_ctx
>>>>>>> 41157b0bc (compiler: Place dataobj pointers inside ctx struct)
