import sympy
from functools import cached_property
import numpy as np
from ctypes import POINTER

from devito.tools import CustomDtype
from devito.types import LocalObject, Eq, CompositeObject
from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction, Symbol
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import Reconstructable, dtype_to_ctype, DAG
from devito.symbolics import FieldFromComposite, Byref
from devito.types.basic import IndexedBase


class DM(LocalObject):
    """
    PETSc Data Management object (DM).
    """
    dtype = CustomDtype('DM')

    def __init__(self, *args, stencil_width=None, **kwargs):
        super().__init__(*args, **kwargs)
        self._stencil_width = stencil_width

    @property
    def stencil_width(self):
        return self._stencil_width
    
    @property
    def info(self):
        return DMDALocalInfo(name='%s_info' % self.name, liveness='eager')
    
    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('DMDestroy', [Byref(self.function)])
        return destroy


class Mat(LocalObject):
    """
    PETSc Matrix object (Mat).
    """
    dtype = CustomDtype('Mat')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('MatDestroy', [Byref(self.function)])
        return destroy


class Vec(LocalObject):
    """
    PETSc Vector object (Vec).
    """
    dtype = CustomDtype('Vec')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('VecDestroy', [Byref(self.function)])
        return destroy


class PetscMPIInt(LocalObject):
    """
    PETSc datatype used to represent `int` parameters
    to MPI functions.
    """
    dtype = CustomDtype('PetscMPIInt')


class KSP(LocalObject):
    """
    PETSc KSP : Linear Systems Solvers.
    Manages Krylov Methods.
    """
    dtype = CustomDtype('KSP')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('KSPDestroy', [Byref(self.function)])
        return destroy


class SNES(LocalObject):
    """
    PETSc SNES : Non-Linear Systems Solvers.
    """
    dtype = CustomDtype('SNES')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('SNESDestroy', [Byref(self.function)])
        return destroy


class PC(LocalObject):
    """
    PETSc object that manages all preconditioners (PC).
    """
    dtype = CustomDtype('PC')

    @property
    def _C_free(self):
        from devito.petsc.utils import petsc_call
        destroy = petsc_call('PCDestroy', [Byref(self.function)])
        return destroy


class KSPConvergedReason(LocalObject):
    """
    PETSc object - reason a Krylov method was determined
    to have converged or diverged.
    """
    dtype = CustomDtype('KSPConvergedReason')


class DMDALocalInfo(LocalObject):
    """
    PETSc object - C struct containing information
    about the local grid.
    """
    dtype = CustomDtype('DMDALocalInfo')


class PetscErrorCode(LocalObject):
    """
    PETSc datatype used to return PETSc error codes.
    https://petsc.org/release/manualpages/Sys/PetscErrorCode/
    """
    dtype = CustomDtype('PetscErrorCode')


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic. They are designed to
    avoid generating a cast in the low-level code.
    Differentiable enables compatability with standard Function objects,
    allowing for the use of the `subs` method.
    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('dimensions', 'shape', 'liveness', 'coefficients',
                    'space_order'))

    def __init_finalize__(self, *args, **kwargs):

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))
        self._shape = kwargs.get('shape')
        self._space_order = kwargs.get('space_order', 1)

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs.get('dtype', np.float32)

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self._shape

    @property
    def space_order(self):
        return self._space_order

    @cached_property
    def _shape_with_inhalo(self):
        """
        Shape of the domain+inhalo region. The inhalo region comprises the
        outhalo as well as any additional "ghost" layers for MPI halo
        exchanges. Data in the inhalo region are exchanged when running
        Operators to maintain consistent values as in sequential runs.

        Notes
        -----
        Typically, this property won't be used in user code, but it may come
        in handy for testing or debugging
        """
        return tuple(j + i + k for i, (j, k) in zip(self.shape, self._halo))

    @cached_property
    def shape_allocated(self):
        """
        Shape of the allocated data of the Function type object from which
        this PETScArray was derived. It includes the domain and inhalo regions,
        as well as any additional padding surrounding the halo.

        Notes
        -----
        In an MPI context, this is the *local* with_halo region shape.
        """
        return DimensionTuple(*[j + i + k for i, (j, k) in zip(self._shape_with_inhalo,
                                                               self._padding)],
                              getters=self.dimensions)

    @cached_property
    def _C_ctype(self):
        # TODO: Reverting to using float/double instead of PetscScalar for
        # simplicity when opt='advanced'. Otherwise, Temp objects must also
        # be converted to PetscScalar. Additional tests are needed to
        # ensure this approach is fine. Previously encountered issues
        # should be resolved as long as we ensure users create Function
        # objects with the same dtype as the precision configured in PETSc.
        return POINTER(dtype_to_ctype(self.dtype))

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.dmda.info) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)

    @property
    def dmda(self):
        name = 'da_so_%s' % self.space_order
        return DM(name=name, liveness='eager', stencil_width=self.space_order)

    @cached_property
    def indexed(self):
        return PETScIndexedData(self.name, shape=self._shape, function=self.function)


class PETScIndexedData(IndexedBase):
    pass


def dtype_to_petsctype(dtype):
    """Map numpy types to PETSc datatypes."""

    return {
        np.int32: 'PetscInt',
        np.float32: 'PetscScalar',
        np.int64: 'PetscInt',
        np.float64: 'PetscScalar'
    }[dtype]


# TODO: Establish clearer and more descriptive names for all PETSc equation types.
# For instance, consider renaming MatVecEq to JacVecEq to reflect its
# specific functionality. Also, may not need all of these equation types after all
# due to recursive compilation.
class MatVecEq(Eq):
    """
    Represents the mathematical expression of applying a linear
    operator to a vector. This is a key component
    for running matrix-free solvers. Represents the lhs operation of
    J(x) * Delta(x) = -F(x).
    """
    pass


class RHSEq(Eq):
    """
    Represents the mathematical expression for constructing the
    right-hand side (RHS) vector `b` in the system of nonlinear
    equations of the form F(x) = b.
    """
    pass


class FormFuncEq(Eq):
    """
    Represents the mathematical expression of constructing
    F(x) in the equation F(x) = b. 
    """
    pass


def PETScSolve(eq, target, bcs=None, solver_parameters=None, **kwargs):
    # TODO: Add check for time dimensions and utilise implicit dimensions.

    is_time_dep = any(dim.is_Time for dim in target.dimensions)
    # TODO: Current assumption is rhs is part of pde that remains
    # constant at each timestep. Need to insert function to extract this from eq.
    y_matvec, x_matvec, b_tmp = [
        PETScArray(name=f'{prefix}_{target.name}',
                   dtype=target.dtype,
                   dimensions=target.space_dimensions,
                   shape=target.grid.shape,
                   liveness='eager',
                   halo=target.halo[1:] if is_time_dep else target.halo)
        for prefix in ['y_matvec', 'x_matvec', 'b_tmp']]

    # TODO: Extend to rearrange equation for implicit time stepping.
    matvecaction = MatVecEq(y_matvec, LinearSolveExpr(eq.lhs.subs(target, x_matvec),
                            target=target, solver_parameters=solver_parameters),
                            subdomain=eq.subdomain)

    # Part of pde that remains constant at each timestep
    rhs = RHSEq(b_tmp, LinearSolveExpr(eq.rhs, target=target,
                solver_parameters=solver_parameters), subdomain=eq.subdomain)

    if not bcs:
        return [matvecaction, rhs]

    else:
        bcs_for_matvec = []
        for bc in bcs:
            # TODO: Insert code to distiguish between essential and natural
            # boundary conditions since these are treated differently within
            # the solver
            # NOTE: May eventually remove the essential bcs from the solve
            # (and move to rhs) but for now, they are included since this
            # is not trivial to implement when using DMDA
            # NOTE: Below is temporary -> Just using this as a palceholder for
            # the actual BC implementation for the matvec callback
            bcs_for_matvec.append(MatVecEq(
                y_matvec, LinearSolveExpr(bc.lhs.subs(target, x_matvec),
                                          target=target,
                                          solver_parameters=solver_parameters),
                subdomain=bc.subdomain))

        return [matvecaction] + bcs_for_matvec + [rhs]


class LinearSolveExpr(sympy.Function, Reconstructable):
    """
    This object is attached to equations that appear
    in the main kernel (e.g setting up the RHS of linear system).
    Other related equations, such as matvec, formfunc, and
    preconditioner equations, are attached to this and recursively
    compiled at the IET level to form the various callback functions.
    """

    __rargs__ = ('expr',)
    __rkwargs__ = ('target', 'solver_parameters', 'matvecs',
                   'formfuncs', 'preconditioner')

    defaults = {
        'ksp_type': 'gmres',
        'pc_type': 'jacobi',
        'ksp_rtol': 1e-7,  # Relative tolerance
        'ksp_atol': 1e-50,  # Absolute tolerance
        'ksp_divtol': 1e4,  # Divergence tolerance
        'ksp_max_it': 10000  # Maximum iterations
    }

    def __new__(cls, expr, target=None, solver_parameters=None,
                matvecs=None, formfuncs=None, preconditioner=None, **kwargs):

        if solver_parameters is None:
            solver_parameters = cls.defaults
        else:
            for key, val in cls.defaults.items():
                solver_parameters[key] = solver_parameters.get(key, val)

        obj = super().__new__(cls, expr)
        obj._expr = expr
        obj._target = target
        obj._solver_parameters = solver_parameters
        obj._matvecs = matvecs
        obj._formfuncs = formfuncs
        obj._preconditioner = preconditioner
        return obj

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.expr)

    __str__ = __repr__

    def _sympystr(self, printer):
        return str(self)

    def __hash__(self):
        return hash(self.target)

    @property
    def expr(self):
        return self._expr

    @property
    def target(self):
        return self._target

    @property
    def solver_parameters(self):
        return self._solver_parameters
    
    @property
    def matvecs(self):
        return self._matvecs
    
    @property
    def formfuncs(self):
        return self._formfuncs
    
    @property
    def preconditioner(self):
        return self._preconditioner

    func = Reconstructable._rebuild


class PETScStruct(CompositeObject):

    __rargs__ = ('name', 'usr_ctx')

    def __init__(self, name, usr_ctx):
        pfields = [(i._C_name, dtype_to_ctype(i.dtype))
                   for i in usr_ctx if isinstance(i, Symbol)]
        self._usr_ctx = usr_ctx
        super().__init__(name, 'MatContext', pfields)

    @property
    def usr_ctx(self):
        return self._usr_ctx

    def _arg_values(self, efuncs, grid, **kwargs):
        # from IPython import embed; embed()
        # args_keys = set(kwargs['args'].keys())
        # efunc = efuncs['MyMatShellMult_pn'].root
        # struct_params = efunc.struct_params
        # filtered_params = [param for param in struct_params if str(param) not in args_keys]

        # nodes = efunc.dimensions
        # edges = [(i, i.parent) for i in efunc.dimensions
        #          if i.is_Derived and i.parent in set(nodes)]
        # toposort = DAG(nodes, edges).topological_sort()




        # from IPython import embed; embed()
        values = super()._arg_values(**kwargs)
        for i in self.fields:
            setattr(values[self.name]._obj, i, kwargs['args'][i])
        return values
